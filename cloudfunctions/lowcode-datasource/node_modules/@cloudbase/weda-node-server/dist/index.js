"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.main = void 0;
const serverless_http_1 = __importDefault(require("serverless-http"));
const app_1 = __importDefault(require("./app"));
const routes_1 = require("./routes");
const weda_node_sdk_1 = require("@cloudbase/weda-node-sdk");
const httpProxy = (0, serverless_http_1.default)(app_1.default, {
    binary: ['image/vnd.microsoft.icon'],
    request: (request, events, context) => {
        // 使用云函数 `context` 入参获取环境变量是更安全的方式
        // 不要依赖 `process.env` 来获取 c 端用户信息
        // 当前版本的云函数在实例复用时不会清除不用的环境变量，对于固定的 B 端信息一般没啥问题，对于变化频繁的 C 端信息就会有严重的串数据问题
        //  在 koa 中可通过 ctx.req 访问 request 对象
        request._scfContext = context;
    },
});
async function main(event, context) {
    weda_node_sdk_1.logger.log('incoming data to cloud function', event);
    let httpEvent = event || {};
    // 获取weda的token信息
    const wedaAccessToken = (httpEvent === null || httpEvent === void 0 ? void 0 : httpEvent.accessToken) || context.accessToken || '';
    const isFnCalling = isCloudFnCalling(httpEvent);
    if (isFnCalling) {
        const { mode, methodName, dataSourceName } = httpEvent, restParams = __rest(httpEvent, ["mode", "methodName", "dataSourceName"]);
        httpEvent = {
            path: getHTTPPath(mode, dataSourceName, methodName),
            httpMethod: 'POST',
            body: JSON.stringify(restParams),
            headers: {
                'content-type': 'application/json',
            },
        };
    }
    const httpRes = await httpProxy(httpEvent, Object.assign(Object.assign({}, context), { wedaAccessToken }));
    let res = httpRes;
    if (isFnCalling) {
        try {
            res = JSON.parse(httpRes.body);
        }
        catch (e) {
            res = httpRes.body;
        }
    }
    return res;
}
exports.main = main;
/**
 * 是否为云函数调用
 */
function isCloudFnCalling(event) {
    var _a;
    /** 非 HTTP调用 即 HTTP 调用 */
    return !(((_a = event.headers) === null || _a === void 0 ? void 0 : _a.host) && event.path);
}
/**
 * 将云函数调用方式转换为 http 调用的路径
 * @param mode 模块, 默认值 ROUTE_NAMES.datasource
 * @param dataSourceName 数据源名称
 * @param methodName 方法名称
 * @returns http path
 */
function getHTTPPath(mode, dataSourceName, methodName) {
    let path = '/';
    // @ts-ignore
    const actualMode = mode ? (routes_1.ROUTE_NAMES[mode] || mode) : routes_1.ROUTE_NAMES.datasource;
    path += actualMode;
    if (actualMode === routes_1.ROUTE_NAMES.datasource) {
        path += `/${dataSourceName}/${methodName}`;
    }
    else if (actualMode === routes_1.ROUTE_NAMES.common) {
        path += `/${methodName}`;
    }
    return path;
}
