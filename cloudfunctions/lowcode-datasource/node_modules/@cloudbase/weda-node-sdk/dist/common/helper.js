"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkIsInScf = exports.safeRequire = exports.isObj = exports.mergeDeep = exports.getDsFullName = exports.dash2smallCamelCase = exports.lowercaseKey = exports.lowercaseWholeKey = exports.capitalizeKey = exports.capitalize = exports.normalizeBuiltinMethodName = exports.fallback2oldMethodName = exports.isBuiltinMethodName = exports.isBuiltinMethod = exports.isNewBuiltinName = void 0;
const logger_1 = require("./logger");
const LEGACY_BUILTIN_METHOD_NAMES = ['create', 'delete', 'update', 'getItem', 'getList', 'getRecords'];
const BUILTIN_NAME_REG = /^weda\S+/;
/**
 * 是否使用的新的数据源内置方法命名
 */
function isNewBuiltinName(name) {
    return BUILTIN_NAME_REG.test(name);
}
exports.isNewBuiltinName = isNewBuiltinName;
/** 是否为内置云函数 */
function isBuiltinMethod(name) {
    return isNewBuiltinName(name) || LEGACY_BUILTIN_METHOD_NAMES.includes(name);
}
exports.isBuiltinMethod = isBuiltinMethod;
exports.isBuiltinMethodName = isBuiltinMethod;
/**
 * 将数据源方法名称倒退回旧名称
 */
function fallback2oldMethodName(name) {
    const oldName = name.replace(/^weda([A-Z])/, ($0, $1) => $1.toLowerCase());
    // 的确为原来支持的内置方法才返回旧名称
    if (LEGACY_BUILTIN_METHOD_NAMES.includes(oldName))
        return oldName;
    return name;
}
exports.fallback2oldMethodName = fallback2oldMethodName;
/**
 * 标准化内置云函数名称, 无 weda 前缀的增加 weda 前缀
 */
function normalizeBuiltinMethodName(name) {
    if (BUILTIN_NAME_REG.test(name))
        return name;
    return `weda${name[0].toUpperCase()}${name.slice(1)}`;
}
exports.normalizeBuiltinMethodName = normalizeBuiltinMethodName;
/** 将字符串首字母大写 */
function capitalize(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
}
exports.capitalize = capitalize;
/**
 * 将对象的key的首字母转换为大写, 适应 yunapi 的命名风格
 *  { userName: 'xxx', id: 'xxx' } => { UserName: 'xxx', Id: 'xxxx'}
 */
function capitalizeKey(obj) {
    const result = {};
    return Object.keys(obj).reduce((acc, key) => {
        const capitalized = capitalize(key);
        acc[capitalized] = obj[key];
        return acc;
    }, result);
}
exports.capitalizeKey = capitalizeKey;
/**
 * 将对象的 key 转换为全小写
 *  for http header usage
 */
function lowercaseWholeKey(obj) {
    const result = {};
    return Object.keys(obj).reduce((acc, cur) => {
        acc[cur.toLowerCase()] = obj[cur];
        return acc;
    }, result);
}
exports.lowercaseWholeKey = lowercaseWholeKey;
/**
 * 将对象的key的首字母转换为小写
 * { UserName: 'xxx', Id: 'xxxx'} => { userName: 'xxx', id: 'xxx' }
 * 默认只处理最外层, 若 deep 为 true, 则递归处理
 */
function lowercaseKey(obj, deep) {
    if (!obj || typeof obj !== 'object')
        return obj;
    if (Array.isArray(obj))
        return obj.map(item => lowercaseKey(item, deep));
    const result = {};
    return Object.keys(obj).reduce((acc, key) => {
        const smallCase = key.charAt(0).toLowerCase() + key.slice(1);
        const val = obj[key];
        acc[smallCase] = deep ? lowercaseKey(val, deep) : val;
        return acc;
    }, result);
}
exports.lowercaseKey = lowercaseKey;
/**
 * 将破折号转换为小驼峰命名方式
 *  dash-name => dashName
 */
function dash2smallCamelCase(str) {
    return str
        .replace(/^-|-$/g, '')
        .replace(/-([^-])/g, ($0, $1) => $1.toUpperCase());
}
exports.dash2smallCamelCase = dash2smallCamelCase;
/**
 * 获取数据源完整名称, 该名称用于发布后的tcb云函数, 也用于tcb的数据库名称
 * @param ds 数据源关键信息
 * @param isPreview 是否预览
 * @returns 数据源表名
 */
function getDsFullName(ds, isPreview) {
    return `lcap-${ds.id}-${ds.name}${isPreview ? '-preview' : ''}`;
}
exports.getDsFullName = getDsFullName;
/* eslint-disable no-param-reassign */
function isObject(obj) {
    return obj && typeof obj === 'object';
}
/**
 * Performs a deep merge of `source` into `target`.
 * Mutates `target` only but not its objects and arrays.
 *
 * @author inspired by [jhildenbiddle](https://stackoverflow.com/a/48218209).
 */
function mergeDeep(target, source) {
    if (!isObject(target) || !isObject(source)) {
        return source;
    }
    Object.keys(source).forEach((key) => {
        const targetValue = target[key];
        const sourceValue = source[key];
        if (Array.isArray(targetValue) && Array.isArray(sourceValue)) {
            target[key] = targetValue.concat(sourceValue);
        }
        else if (isObject(targetValue) && isObject(sourceValue)) {
            target[key] = mergeDeep(Object.assign({}, targetValue), sourceValue);
        }
        else {
            target[key] = sourceValue;
        }
    });
    return target;
}
exports.mergeDeep = mergeDeep;
/** 是否为对象(非数组) */
function isObj(obj, key) {
    const target = obj && key ? obj[key] : obj;
    if (!target)
        return false;
    return !Array.isArray(target) && typeof target === 'object';
}
exports.isObj = isObj;
/**
 * 安全require, 如果引入的路径不存在, 或者文件内容语法错误, 则返回undefined, 而不会crash整个代码
 */
function safeRequire(filePath, needErrorStack) {
    try {
        // eslint-disable-next-line @typescript-eslint/no-require-imports
        return require(filePath);
    }
    catch (error) {
        logger_1.logger.log('failed to require', filePath, error);
        if (needErrorStack)
            return error.stack || error.message;
    }
}
exports.safeRequire = safeRequire;
function checkIsInScf() {
    // TENCENTCLOUD_RUNENV
    return process.env.TENCENTCLOUD_RUNENV === 'SCF';
}
exports.checkIsInScf = checkIsInScf;
