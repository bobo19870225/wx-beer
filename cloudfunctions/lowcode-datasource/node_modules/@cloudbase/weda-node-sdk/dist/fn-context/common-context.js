"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getUserSourceCache = exports.setCommonContext = exports.getCommonContext = exports.generatePrivateContext = void 0;
/* eslint-disable max-len */
/**
 * 公共 context 信息, 与特定数据源无关的 context
 */
const tcb_1 = require("../tcb");
const config_1 = require("../config");
const remote_api_1 = require("../remote-api");
const common_1 = require("../common");
let cachedCommonContext;
/**
 * 生成私有化的context
 * @param contextIn
 * @returns
 */
function generatePrivateContext(contextIn) {
    var _a;
    if (contextIn === undefined)
        return contextIn;
    const context = Object.assign({}, contextIn);
    if ((_a = contextIn.privateInfo) === null || _a === void 0 ? void 0 : _a.isPrivate) {
        if (contextIn.envInfo) {
            context.env = new Proxy(contextIn.envInfo, {
                get(target, prop, handler) {
                    if (typeof prop === 'string' && !['customUserId', 'isAnonymous', 'dataSourceName', 'dataSourceFullName', 'envId', 'isPreview', 'envType'].includes(prop)) {
                        throw new common_1.TCBError('INVALID_OPERATION', `Current ENV run in a hybrid cloud cannot support this action [env.${prop}]`, { reason: `private env do not support env.${prop}` });
                    }
                    return Reflect.get(target, prop, handler);
                },
            });
            context.envInfo = context.env;
        }
        return new Proxy(context, {
            get(target, prop, handler) {
                if (typeof prop === 'string' && ['callWxOpenApi', 'cloudbase', 'app', 'auth', 'databases', 'collection', 'httpAuth'].includes(prop)) {
                    throw new common_1.TCBError('INVALID_OPERATION', `Current ENV run in a hybrid cloud cannot support this action [${prop}]`, { reason: `private env do not support ${prop}` });
                }
                return Reflect.get(target, prop, handler);
            },
        });
    }
    return contextIn;
}
exports.generatePrivateContext = generatePrivateContext;
function getCommonContext() {
    if (!cachedCommonContext) {
        common_1.logger.warn('common context not initialed yet');
    }
    return cachedCommonContext;
}
exports.getCommonContext = getCommonContext;
/**
 * 解析weda的accessToken
 * @param wedaAccessToken
 * @returns
 */
const parseWedaAccessToken = (wedaAccessToken) => {
    var _a, _b;
    try {
        if (wedaAccessToken) {
            const payload = new Buffer((_b = (_a = wedaAccessToken.split('.')) === null || _a === void 0 ? void 0 : _a[1]) === null || _b === void 0 ? void 0 : _b.replace(/-/g, '+').replace(/_/g, '/'), 'base64').toString();
            return JSON.parse(payload) || {};
        }
    }
    catch (error) {
        return {};
    }
    return {};
};
/**
 * 设置公共的context
 */
async function setCommonContext(config) {
    // if (cachedCommonContext) {
    // 在云函数中存在对象共享的问题, 多次云函数调用可能用共享同一个内存对象
    // console.warn('<cachedCommonContext> should be called only once!');
    // return cachedCommonContext;
    // }
    const parsedContext = tcb_1.tcb.parseContext(config.rawContext);
    const envInfo = getEnvInfo(config);
    /**
     * 直接调用weda api
     */
    const callWedaApi = (params) => {
        const newParams = Object.assign(Object.assign({}, params), { requestId: true });
        return (0, remote_api_1.fetchWeda)(newParams);
    };
    /**
     * 调用微信开放接口
     */
    const callWxOpenApi = async (params) => await (0, remote_api_1.fetchWeda)({
        action: 'InvokeWxSpData',
        data: Object.assign({ wxAppId: envInfo.currentAppId }, params),
    });
    const privateInfo = {
        isPrivate: envInfo.isPrivate,
        tcbHost: envInfo.tcbHost,
    };
    cachedCommonContext = {
        callDataSource: config.callDataSource,
        callConnector: config.callConnector,
        callModel: config.callModel,
        callWedaApi,
        callWorkflow: callWedaApi,
        callWxOpenApi,
        cloudbase: tcb_1.tcb,
        app: tcb_1.app,
        auth: tcb_1.auth,
        env: envInfo,
        envInfo,
        database: tcb_1.db,
        weixin: getWxCloudInfo(config.cfnParams),
        wedaTarget: config.cfnParams.wedaTarget,
        extraHeaders: config.cfnParams._weda,
        parsedRawContext: parsedContext,
        wedaAccessToken: config.wedaAccessToken,
        privateInfo,
    };
    // 仅当预览云函数才能设置为测试模式
    const isTestMode = envInfo.isPreview && config.cfnParams.isTestMode;
    (0, config_1.setConfig)({
        getDataSources: config.getDataSources,
        wedaTarget: cachedCommonContext.wedaTarget,
        requestId: parsedContext.requestId,
        entrance: config.entrance,
        isTestMode,
        testDataSource: isTestMode && config.cfnParams.testDataSource,
        envType: envInfo.envType,
        wedaAppId: config.cfnParams.wedaAppId,
        wedaAccessToken: config.wedaAccessToken,
        privateInfo,
    });
    // getUserSource 内部可能依赖 config 信息, 所以得先执行 setConfig
    const userSource = await getUserSourceCache(envInfo, config);
    (0, config_1.setConfig)({ userSource });
    return cachedCommonContext;
}
exports.setCommonContext = setCommonContext;
/**
 * 获取环境变量信息
 */
function getEnvInfo(config) {
    var _a;
    const wedaInfo = parseWedaAccessToken(config.wedaAccessToken || '');
    common_1.logger.log('wedaInfo', wedaInfo);
    const envTypeInfo = getEnvType(config);
    const envObj = (0, config_1.getCloudbaseContext)(config.rawContext);
    // @ts-ignore
    const currentOpenId = envObj.WX_FROM_OPENID || envObj.WX_OPENID; // 非全托管时会有值
    // @ts-ignore
    const currentAppId = envObj.WX_FROM_APPID || envObj.WX_APPID; // 非全托管时会有值
    // 解析的openId，优先从wedaAccessToken获取，没有则从上下文获取
    const parsedOpenId = (/^w[xw]/.test(wedaInfo.provider || '') ? (wedaInfo.provider_sub || '') : '') || currentOpenId;
    return Object.assign(Object.assign({}, envTypeInfo), { token: {}, tcbSource: envObj.TCB_SOURCE || '', wedaAppId: config.cfnParams.wedaAppId, clientIp: envObj.WX_CLIENTIP || envObj.TCB_SOURCE_IP, currentOpenId,
        currentAppId, openId: envObj.WX_OPENID, 
        // @ts-ignore
        fromOpenId: envObj.WX_FROM_OPENID, appId: envObj.WX_APPID, 
        // @ts-ignore
        fromAppId: envObj.WX_FROM_APPID, uid: envObj.TCB_UUID, customUserId: envObj.TCB_CUSTOM_USER_ID || '', isAnonymous: envObj.TCB_ISANONYMOUS_USER === 'true', envId: envObj.TCB_ENV || envObj.SCF_NAMESPACE, roles: wedaInfo.groups || ((_a = config.cfnParams) === null || _a === void 0 ? void 0 : _a.wedaGroups), tcbHost: envObj.SCF_ROUTE_TO_TCB_HOST, isPrivate: envObj.IS_PRIVATE_ENV === 'true', parsedOpenId, wedaInfo: Object.assign(Object.assign({}, wedaInfo), { openId: (wedaInfo === null || wedaInfo === void 0 ? void 0 : wedaInfo.openId) || parsedOpenId, appId: (wedaInfo === null || wedaInfo === void 0 ? void 0 : wedaInfo.provider) || currentAppId }) });
}
/**
 * 获取环境类型信息, 返回 { isPreview, envType }
 *  优先使用 config.isPreview 判断环境类型, 再使用环境变量, 最后才使用 params 中的 envType
 */
function getEnvType(config) {
    let isPreview;
    let { envType } = config.cfnParams;
    if (isPreview === undefined && process.env.IS_PREVIEW === 'true') {
        isPreview = true;
    }
    if (isPreview === undefined) {
        if (envType) {
            isPreview = envType === 'pre';
            return {
                isPreview,
                envType,
            };
        }
        isPreview = true;
    }
    envType = isPreview ? 'pre' : 'prod';
    return {
        isPreview,
        envType,
    };
}
/**
 * 获取微信侧用户授权信息
 * @param params 云函数额外参数
 * @returns
 */
function getWxCloudInfo(params) {
    const wxReg = /^wx_/;
    const wxKeys = Object.keys(params).filter(k => wxReg.test(k));
    if (!wxKeys.length)
        return null;
    const weixin = {};
    return wxKeys.reduce((acc, cur) => {
        acc[cur.replace(wxReg, '')] = params[cur];
        return acc;
    }, weixin);
}
/** 缓存当前环境对应的管理员Id */
let cachedAdminId = '';
/** 获取用户来源信息 */
async function getUserSourceCache(envInfo, config) {
    var _a;
    const openId = envInfo.currentOpenId;
    const tcbUid = envInfo.uid;
    if (!openId && !tcbUid) {
        // `,`结尾表示没有来源, 一般为本地调用
        if (config.useAdmin
            || ((_a = config.cfnParams) === null || _a === void 0 ? void 0 : _a.isTestMode)
            || /(^,|\bscf$)/i.test(envInfo.tcbSource)) {
            // 来自本地调用或者被其他云函数调用, 此时允许使用传递过来的 source 信息
            // if (config.cfnParams.userSource) return config.cfnParams.userSource;
            // 测试模式使用当前环境的管理员id
            if (!cachedAdminId) {
                cachedAdminId = await (0, remote_api_1.fetchWeda)({
                    action: 'DescribeAdministrator',
                }, true).then((res) => {
                    var _a;
                    if ((_a = res.Data) === null || _a === void 0 ? void 0 : _a.UserId) {
                        return res.Data.UserId;
                    }
                    throw new common_1.TCBError('InnerError', '无法获取管理员账号信息', {
                        reason: `unable to get admin Id, original response: ${JSON.stringify(res)}`,
                    });
                });
            }
            return {
                uid: cachedAdminId,
                source: 4,
            };
        }
        return;
    }
    return {
        uid: (openId || tcbUid),
        /** uid 类型, 1.tcb 2.微信 3.企业微信 4.weda内部 */
        source: openId ? 2 : 1,
    };
}
exports.getUserSourceCache = getUserSourceCache;
