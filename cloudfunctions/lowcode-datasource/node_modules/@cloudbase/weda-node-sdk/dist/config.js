"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getTriggerSource = exports.TRIGGER_SOURCE_HEADER = exports.getDataSource = exports.isMethodInTestMode = exports.getDefaultParams = exports.getUserSource = exports.getCloudbaseContext = exports.generateGetCollectionName = exports.getConfig = exports.setConfig = void 0;
const node_sdk_1 = __importDefault(require("@cloudbase/node-sdk"));
const common_1 = require("./common");
;
/**
 * node-sdk 内部共享的配置信息
 *  !!TODO: 在云函数中, 单进程, 信息不共享, 不会出现数据串的问题, 但放到云托管中, 则会有问题
 */
const config = {};
/**
 * 设置配置, 应当只在 get-fn-context 中调用
 */
function setConfig(cfg) {
    Object.assign(config, cfg);
}
exports.setConfig = setConfig;
function getConfig(key) {
    return key ? config[key] : config;
}
exports.getConfig = getConfig;
let cachedGetCollectionName;
/** 生成获取数据源对应数据库名称的方法 */
async function generateGetCollectionName(isPreview) {
    if (cachedGetCollectionName)
        return Promise.resolve(cachedGetCollectionName);
    const datasources = await config.getDataSources();
    cachedGetCollectionName = (dsName) => {
        const ds = datasources.find(item => item.name === dsName);
        if (!ds)
            throw new common_1.TCBError('UserError.DsNotFound', `找不到数据源 ${dsName}`, {
                reason: `datasource ${dsName} not found when calling getCollectionName`,
            });
        if (ds.type !== 'database')
            throw new common_1.TCBError('UserError.DsMisuse', `${dsName}非自建数据源, 无对应的自建数据库`, {
                reason: `calling getCollectionName on none-database datasource ${dsName}`,
            });
        return (0, common_1.getDsFullName)(ds, isPreview);
    };
    return cachedGetCollectionName;
}
exports.generateGetCollectionName = generateGetCollectionName;
// 缓存解析的完整的云函数context信息
let parsedContext;
/**
 * 解析云函数的 context
 *  为保证能获取到完整的context信息, 应当保证在第一次调用时有传入 context
 * @param context tcb 云函数的context, 即 main 函数的第二个参数
 */
function getCloudbaseContext(context) {
    if (context) {
        parsedContext = Object.assign({}, node_sdk_1.default.getCloudbaseContext(context));
        return parsedContext;
    }
    return (parsedContext || node_sdk_1.default.getCloudbaseContext());
}
exports.getCloudbaseContext = getCloudbaseContext;
/** 获取用户来源信息 */
function getUserSource() {
    return getConfig('userSource');
}
exports.getUserSource = getUserSource;
/**
 * 获取数据源方法的默认参数
 *  同一个数据源下, 所有方法均共享同样的参数
 * @param dataSourceName 数据源名称
 */
function getDefaultParams(dataSourceName) {
    if (!config.entrance
        || !config.defaultParams
        // 默认值非对象则直接忽略
        || !(0, common_1.isObj)(config.defaultParams)
        || dataSourceName !== config.entrance.dataSourceName)
        return null;
    return Object.assign({}, config.defaultParams);
}
exports.getDefaultParams = getDefaultParams;
/**
 * 当前方法是否处于测试模式中
 */
function isMethodInTestMode(dataSourceName, methodName) {
    return (config.isTestMode
        && config.entrance
        && dataSourceName === config.entrance.dataSourceName
        && methodName === config.entrance.methodName);
}
exports.isMethodInTestMode = isMethodInTestMode;
/**
 * 获取当前数据源描述对象
 *  若为测试模式, 则使用 config.testDataSource
 */
function getDataSource(dataSource) {
    // 非测试模式/测试数据源为空/当前数据源非被测试的数据源
    if (!config.isTestMode
        || !config.testDataSource
        || dataSource.name !== config.testDataSource.name)
        return dataSource;
    /**
     * 前端测试为了优化请求体大小, 会只传入当前测试的方法的配置
     *  在此对方法进行合并, 优先采用传递过来的方法
     *
     * 可能的bug: 用户将测试的方法改名, 将导致实际测试过程中新旧名称的方法均可以调用
     */
    let methods = config.testDataSource.methods || [];
    methods = methods.concat(dataSource.methods || []);
    methods = methods.filter((m, idx) => methods.findIndex(item => item.name === m.name) === idx);
    return Object.assign({}, config.testDataSource, { methods });
}
exports.getDataSource = getDataSource;
/**
 * 数据源云函数调用来源的环境变量名, 也会作为回传时候的http header名
 */
exports.TRIGGER_SOURCE_HEADER = 'X-Trigger-Source';
/**
 * 获取当前数据源的调用来源
 *  为避免字母大小写转换问题, 在此尝试各种方式获取
 * @returns 当前调用来源
 */
function getTriggerSource() {
    return (process.env[exports.TRIGGER_SOURCE_HEADER]
        || process.env[exports.TRIGGER_SOURCE_HEADER.toLowerCase()]
        || process.env[exports.TRIGGER_SOURCE_HEADER.toUpperCase()]);
}
exports.getTriggerSource = getTriggerSource;
