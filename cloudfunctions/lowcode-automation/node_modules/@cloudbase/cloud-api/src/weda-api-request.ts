// @ts-ignore
import { sign } from '@cloudbase/signature-nodejs';
import util from 'util';
import URL from 'url';
import qs from 'query-string';
import { fetch } from './request';
import { CloudBaseError } from './error';

const debuglog = util.debuglog('weda-request');

/** 默认接口请求地址 */
const WEDA_API_URL = {
  /** 运行态接口 */
  runtime: {
  /** 线网地址 */
    prod: 'https://gateway.weda.tencent-cloud.com/wedaapi',
    /** 体验地址 */
    demo: 'https://gateway-demo.weda.tencent-cloud.com/wedaapi',
    /** 预发地址 */
    pre: 'https://gateway-preview.weda.tencent-cloud.com/wedaapi',
  },
  /** 设计态接口 */
  design: {
  /** 线网地址 */
    prod: 'https://gateway.weda.tencent-cloud.com/designrestful',
    /** 体验地址 */
    demo: 'https://gateway-demo.weda.tencent-cloud.com/designrestful',
    /** 预发地址 */
    pre: 'https://gateway-preview.weda.tencent-cloud.com/designrestful',
  }
};

/** 默认配置 */
const DEFAULT_CONFIG: IWedaConfig = {
  url: WEDA_API_URL.runtime.prod,
  method: 'POST',
};

interface ICredentials {
  secretId: string
  secretKey: string
  sessionToken: string
}

/**
 * 请求参数
 */
export interface IWedaRequestParams {
  /** 请求方法 */
  action: string;
  /**
   * 认证信息
   *  在tcb云函数中可通过 tcb.getCloudbaseContext 返回的环境变量获取相关信息:
   *    TENCENTCLOUD_SECRETID
   *    TENCENTCLOUD_SECRETKEY
   *    TENCENTCLOUD_SESSIONTOKEN
   */
  credentials: ICredentials | (() => Promise<ICredentials>)
  /** 环境ID */
  envId: string;
  /**
   * 客户端IP地址, 方便后端进行统计, 无可不传
   *  在tcb云函数中可通过 tcb.getCloudbaseContext 返回的 WX_CLIENTIP(微信侧) TCB_SOURCE_IP(云开发侧)拿到客户端IP地址
   *  详细文档 https://docs.cloudbase.net/api-reference/server/node-sdk/env.html#getcloudbasecontext
   */
  clientIp?: string
  /**
   * 自定义请求ID, 方便前后端调试, 无可不传
   *  在tcb 云函数中, 若可以保证前端一次云函数调用, 只向weda后端发起一次请求, 这可以通过 tcb.parseContext 拿到云函数的请求 request_id 并复用该ID
   *    若不能保证上述条件, 则不要复用云函数请求ID, 否则导致请求链路出问题难以定位
   *  详细文档 https://docs.cloudbase.net/api-reference/server/node-sdk/env.html#parsecontext
   */
  requestId?: string
  /**
   * 调用的weda环境类型
   *  预览-pre，正式-prod
   */
  envType: 'pre' | 'prod'
  /** 用户ID */
  uid: string;
  /** 
   * uid 类型, 1.tcb 2.微信 3.企业微信 4.weda内部
   */
  source: 1 | 2 | 3 | 4
  /**
   * 方法的其他参数
   */
  data?: Record<string, any>
}

/**
 * 请求额外配置
 */
export interface IWedaConfig {
  /** 请求的接口地址, 默认 'https://gateway.weda.tencent-cloud.com/wedaapi' */
  url: string
  /**
   * 请求目标, 与 url 意义类似, 但可通过设置为 prod/pre 来指定地址, **优先使用 target**
   * 可以是下边三个值
   *  'prod' 正式地址
   *  'pre' 预发地址
   *  'demo' 体验地址 
   *  url 任意一个url
   */
  target?: string
  /**
   * 调用的服务类型, 默认 runtime. 配合 target 会调用到不同的接口 url 地址
   *   runtime: 运行态接口
   *   design: 设计态接口
   */
  serviceType?: 'runtime' | 'design'
  /** 请求方法, 默认 POST */
  method: string
  /** 额外的自定义头 */
  headers?: Record<string, any>
  /** 自定义http代理地址 */
  proxy?: string
  /** 自定义日志处理函数 */
  logger?: (...args: any[]) => void
}

export async function wedaRequest(params: IWedaRequestParams, config?: Partial<IWedaConfig>) {
  const logger = config?.logger || debuglog;
  logger('[wedaRequest] raw params: ', {
    ...params,
    credentials: params?.credentials ? '<masked credentials>' : '<no credentials provided>'
  }, 'config', config);
  const commonConfig = { ...DEFAULT_CONFIG, ...(config||{})};
  let url = commonConfig.url;
  if (commonConfig.target || commonConfig.serviceType) {
    if (commonConfig.target && /^https?:\/\//i.test(commonConfig.target)) {
      url = commonConfig.target;
    } else {
      const targetMap = WEDA_API_URL[commonConfig.serviceType] || WEDA_API_URL.runtime;
      url = targetMap[commonConfig.target] || targetMap.prod;
    }
  }

  commonConfig.url = url || WEDA_API_URL.runtime.prod;

  let credentials = params.credentials;
  if (typeof credentials === 'function') {
    try {
      credentials = await credentials();
    } catch (e) {
      throw new CloudBaseError(e.message, {
        action: '_credentials_',
        original: e
      });
    }
  }

  /** 请求参数 */
  const data = {
    ...(params.data || {}),
    Action: params.action,
    EnvType: params.envType,
    EnvId: params.envId,
    Uid: params.uid,
    Source: params.source,
    ClientIp: params.clientIp,
    RequestId: params.requestId,
  };

  const method = commonConfig.method.toUpperCase();
  const requestConfig: any = { 
    method
  };
  let body: any = '';
  // 设置 content-type 及 body/querystring
  commonConfig.headers = commonConfig.headers || {};
  if (['GET', 'DELETE'].includes(method)) {
    let url = commonConfig.url;
    commonConfig.headers['Content-Type'] = 'application/x-www-form-urlencoded';
    url += /\?/.test(commonConfig.url) ? '&' : '?';
    url += qs.stringify(data);
    commonConfig.url = url;
  } else if (['POST', 'PUT'].includes(method)) {
    commonConfig.headers['Content-Type'] = 'application/json';
    requestConfig.body = JSON.stringify(data);
    body = requestConfig.body;
  }
  
  const headers = getHeaders({
    ...commonConfig,
    credentials,
    params: body,
  });
  requestConfig.headers = headers;

  try {
    logger(`[wedaRequest] request, request target: ${commonConfig.url}, method: ${requestConfig.method}, action: ${params.action}`);
    const data = await fetch(commonConfig.url, requestConfig, commonConfig.proxy);
    logger('[wedaRequest] after request, requestId:', data.Response.RequestId, 'raw response:', data);
    if (data.Response.Error) {
      const tcError = new CloudBaseError(data.Response.Error.Message, {
        action: params.action,
        requestId: data.Response.RequestId,
        code: data.Response.Error.Code,
        original: data.Response.Error
      });
      throw tcError;
    } else {
      return data.Response;
    }
  } catch (e) {
    // throw e
    if (e.name === 'CloudBaseError') {
      throw e;
    } else {
      throw new CloudBaseError(e.message, {
        action: params.action,
        code: e.code,
        type: e.type
      });
    }
  }
}

interface IGetHeaderOptions {
  url: string
  method: string,
  credentials: ICredentials,
  headers?: Record<string, string|number>
  params: Record<string, any>
}

function getHeaders(options: IGetHeaderOptions) {
  const headers: Record<string, string|number> = {
    ...(options.headers || {}),
    // 'X-URL': options.url,
    'X-SessionToken': options.credentials.sessionToken,
    Host: URL.parse(options.url).host,
  };

  const second = Math.floor(Date.now() / 1000);

  const { authorization, timestamp } = sign({
    secretId: options.credentials.secretId,
    secretKey: options.credentials.secretKey,
    method: options.method,
    url: options.url,
    params: options.params,
    headers,
    withSignedParams: false,
    timestamp: second - 1
  });

  headers['X-Authorization'] = authorization;
  headers['X-Signature-Expires'] = 600;
  headers['X-Timestamp'] = timestamp;

  return headers;
}
