"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const koa_1 = __importDefault(require("koa"));
const koa_body_1 = __importDefault(require("koa-body"));
const weda_node_sdk_1 = require("@cloudbase/weda-node-sdk");
require("./unhandled-error");
const routes_1 = __importStar(require("./routes"));
const config_1 = require("./config");
const call_datasource_1 = require("./fns/call-datasource");
const load_datasources_1 = require("./fns/load-datasources");
const app = new koa_1.default();
/**
 * 统一通用处理
 *  1. 成功的返回结果添加 { code, data } 包装
 *  2. 失败后, 失败的包装
 */
const generalHandler = async function (ctx, next) {
    var _a;
    try {
        await next();
        // 包装接口请求返回的结构体, POST 为正常请求接口的方法
        //  graphql 的请求已经符合预期, 无需额外处理
        if (ctx.method === 'POST' && ctx.path !== `/${routes_1.ROUTE_NAMES.graphql}`) {
            ctx.body = {
                code: 0,
                data: ctx.body,
            };
        }
    }
    catch (err) {
        weda_node_sdk_1.logger.error('datasource calling error:', err.message, (err.getStack ? err.getStack() : err.stack));
        let { code } = err;
        if (!code) {
            code = ((_a = config_1.HTTP_CODE_MAP[err.statusCode || err.status]) === null || _a === void 0 ? void 0 : _a.code) || 'UnknownError';
        }
        // err.statusCode || err.status || 500;
        ctx.status = 200;
        ctx.body = {
            code,
            message: err.message,
            reason: err.reason,
            // 隐藏 stack, 避免安全隐患
            // stack: err.getStack ? err.getStack() : err.stack,
        };
    }
};
/**
 * 更新数据源 sdk 所需的公共context信息
 */
const updateCommonContext = async function (ctx, next) {
    var _a;
    const requestBody = Object.assign({}, ctx.query, ctx.request.body);
    const { testDataSource } = requestBody;
    const userAgent = ctx.request.get('User-Agent') || requestBody.userAgent;
    // http header 中 Referer 为错别字, 正确应为 Referrer
    const referrer = ctx.request.get('Referer') || requestBody.referrer;
    /** 设置与具体数据源无关的公共 context 信息, 并打印相关日志 */
    await (0, weda_node_sdk_1.setCommonContext)({
        callDataSource: call_datasource_1.callDataSource,
        callConnector: call_datasource_1.callDataSource,
        callModel: call_datasource_1.callDataSource,
        /** 获取数据源列表方法, 方便 node-sdk 内部 context.getCollectionName 方法的实现 */
        getDataSources: load_datasources_1.loadDataSources,
        // 仅本地 server 模式使用环境变量中的模拟 context
        // @ts-ignore
        rawContext: ctx.req._scfContext || (config_1.ENABLE_LOCAL_SERVER && global.TEST_CONTEXT),
        wedaAccessToken: (_a = ctx.req._scfContext) === null || _a === void 0 ? void 0 : _a.wedaAccessToken,
        // 调用入口的方法、方法名, 主要用于测试模式中对当前测试的方法进行特殊处理
        entrance: getCallEntrance(ctx),
        cfnParams: Object.assign(Object.assign({}, requestBody), { referrer,
            userAgent, testDataSource: testDataSource && (0, load_datasources_1.standardizeDataSource)(testDataSource) }),
    });
    return next();
};
/**
 * 获取入口处调用的数据源名称及方法名
 */
function getCallEntrance(ctx) {
    const paths = ctx.path.replace('/', '').split('/');
    const category = paths[0];
    if (category === routes_1.ROUTE_NAMES.common)
        return;
    if (category === routes_1.ROUTE_NAMES.datasource) {
        return { dataSourceName: paths[1], methodName: paths[2] };
    }
    // graphql 调用时, 可能同时调用多个方法, 方法测试也不支持graphql, 故在此不做处理
}
app.use(generalHandler);
app.use((0, koa_body_1.default)());
app.use(updateCommonContext);
// 注意, route 的中间件不能调用 next, 否则将触发下边的 404 handler
routes_1.default.forEach(route => app.use(route));
if (!config_1.IS_DEV) {
    // 其他默认 404 处理
    app.use((ctx) => {
        ctx.throw(404, 'route not found');
    });
}
exports.default = app;
