"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDatasource = exports.setDataSources = exports.getAllBuiltinMethodName = exports.isGraphqlActionType = exports.getMethodOutTypeName = exports.getMethodInTypeName = exports.getRootFieldName = void 0;
const weda_node_sdk_1 = require("@cloudbase/weda-node-sdk");
/** 获取graphql方法名称  */
function getRootFieldName(dataSourceName, methodName) {
    return `${dataSourceName}${(0, weda_node_sdk_1.capitalize)(methodName)}`;
}
exports.getRootFieldName = getRootFieldName;
/** 获取graphql方法入参的类型名称 */
function getMethodInTypeName(dataSourceName, methodName, isBuiltin) {
    const rinsedMethodName = isBuiltin ? (0, weda_node_sdk_1.normalizeBuiltinMethodName)(methodName) : methodName;
    return `${getRootFieldName(dataSourceName, rinsedMethodName)}Payload`;
}
exports.getMethodInTypeName = getMethodInTypeName;
/** 获取graphql方法出参的类型名称 */
function getMethodOutTypeName(dataSourceName, methodName, isBuiltin) {
    const rinsedMethodName = isBuiltin ? (0, weda_node_sdk_1.normalizeBuiltinMethodName)(methodName) : methodName;
    return `${getRootFieldName(dataSourceName, rinsedMethodName)}Response`;
}
exports.getMethodOutTypeName = getMethodOutTypeName;
/** 内置的 mutation 方法名称, 其他内置方法则为 query */
const BUILTIN_MUTATION_ACTION_NAMES = [
    'create', 'wedaCreate',
    'delete', 'wedaDelete',
    'update', 'wedaUpdate',
];
/**
 * 当前方法是否为 graphql 指定的方法类型
 *  @param method 字符串则是内置方法名, 对象则为自定义方法
 */
function isGraphqlActionType(type, method) {
    if (typeof method === 'string') {
        const isMutationName = BUILTIN_MUTATION_ACTION_NAMES.includes(method);
        // 以下可缩写成 isMutationName === ((type === 'mutation')), 但可读性不佳
        if (type === 'mutation') {
            return isMutationName;
        }
        return !isMutationName;
    }
    return true;
}
exports.isGraphqlActionType = isGraphqlActionType;
/**
 * 内置方法的旧名称, 不带 weda 前缀
 */
const OLD_BUILTIN_METHOD_NAMES = ['getList', 'create', 'delete', 'getItem', 'update', 'getRecords'];
/**
 * 获取带weda前缀及不带前缀的内置方法名称
 * @param names 内置方法名
 */
function getAllBuiltinMethodName(names) {
    if (!names || !names.length)
        return [];
    // 转换为不带 weda 前缀的名称并且名称包含在旧的内置方法名称中
    //  这些名称需要做名称 weda 是否加前缀的处理, 其他新增方法无此问题, 不必兼容
    const oldNames = names
        .map(name => name.replace(/^weda([A-Z])/, ($0, $1) => $1.toLowerCase()))
        .filter(n => OLD_BUILTIN_METHOD_NAMES.includes(n));
    // 旧的数据源描或旧的应用模版带的数据源述中可能没有 getRecords 方法, 在此 保证内置数据源一定可以使用 getRecords
    if (oldNames.indexOf('getRecords') === -1)
        oldNames.push('getRecords');
    // 带 weda 前缀的名称
    const newNames = oldNames.map(name => `weda${name.charAt(0).toUpperCase()}${name.slice(1)}`);
    const allNames = names.concat(oldNames.concat(newNames));
    // 名称去重
    return allNames.filter((n, idx) => allNames.indexOf(n) === idx);
}
exports.getAllBuiltinMethodName = getAllBuiltinMethodName;
/** 缓存的数据源描述数组 */
let CACHED_DATASOURCES = [];
/** 更新数据源描述数组 */
function setDataSources(datasources) {
    CACHED_DATASOURCES = datasources;
}
exports.setDataSources = setDataSources;
/**
 * 查询数据源描述对象
 * @param ds 字符串即为数据源标识, 对象则为数据源对象
 */
function getDatasource(ds) {
    if (typeof ds === 'object')
        return ds;
    return CACHED_DATASOURCES.find(item => item.name === ds);
}
exports.getDatasource = getDatasource;
