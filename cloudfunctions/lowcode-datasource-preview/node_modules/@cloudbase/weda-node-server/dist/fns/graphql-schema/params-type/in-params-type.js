"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getInputTypeFromSchema = exports.getPayloadTypeFromSchema = exports.getInParamsType = exports.DATABASE_BUILTIN_FIELDS_WITHOUT_ID = exports.DATABASE_BUILTIN_FIELDS = void 0;
const graphql_1 = require("graphql");
const weda_node_sdk_1 = require("@cloudbase/weda-node-sdk");
const utils_1 = require("../utils");
const common_1 = require("./common");
/**
 * 自建数据源内置字段
 */
exports.DATABASE_BUILTIN_FIELDS = ['_id', 'createBy', 'createdAt', 'owner', 'updatedAt', 'updateBy'];
// 内置字段中除了 _id 之外的字段
exports.DATABASE_BUILTIN_FIELDS_WITHOUT_ID = exports.DATABASE_BUILTIN_FIELDS.filter(k => k !== '_id');
/**
 * 获取数据源方法入参 args 对象
 * @param datasource 数据源对象
 * @param method 方法名, 字符串表示内置方法名, 对象则为自定义方法名
 * @returns 入参为空时, 返回空, 否则返回字段配置对象
 */
function getInParamsType(datasource, method) {
    if (typeof method === 'string') {
        const payloadTypeName = (0, utils_1.getMethodInTypeName)(datasource.name, method, true);
        const standardMethodName = (0, weda_node_sdk_1.normalizeBuiltinMethodName)(method);
        const handler = builtinMethodPayloadType[standardMethodName];
        if (!handler) {
            throw new weda_node_sdk_1.TCBError('GLError.NotImplemented', `GraphQL暂时未支持该内置方法 ${method}`, {
                reason: `builtin method ${method} payloadType not implemented in graphql mode`,
            });
        }
        return handler(payloadTypeName, datasource);
    }
    if (!method.inParams)
        return;
    return getPayloadTypeFromSchema((0, utils_1.getMethodInTypeName)(datasource.name, method.name, true), method.inParams);
}
exports.getInParamsType = getInParamsType;
/** 内置方法类型 */
const builtinMethodPayloadType = {
    wedaGetItem() {
        return { _id: { type: common_1.SCALAR_TYPES.id, description: '记录ID' } };
    },
    wedaGetList() {
        return { params: { type: common_1.SCALAR_TYPES.any, description: '查询条件' } };
    },
    wedaGetRecords() {
        return getPayloadTypeGetRecords();
    },
    wedaDelete() {
        return { _id: { type: common_1.SCALAR_TYPES.id, description: '记录ID' } };
    },
    wedaCreate(typeName, datasource) {
        return getPayloadTypeFromSchema(typeName, datasource.schema, exports.DATABASE_BUILTIN_FIELDS);
    },
    wedaUpdate(typeName, datasource) {
        return getPayloadTypeFromSchema(typeName, datasource.schema, exports.DATABASE_BUILTIN_FIELDS_WITHOUT_ID);
    },
};
/**
 * getRecords where Graphql 类型
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
const WhereType = new graphql_1.GraphQLList(new graphql_1.GraphQLInputObjectType({
    name: 'WedaWhereType',
    fields: {
        key: { type: common_1.SCALAR_TYPES.string, description: '字段名称' },
        rel: { type: common_1.SCALAR_TYPES.string, description: '字段与值之间的关系' },
        val: { type: common_1.SCALAR_TYPES.any, description: '字段值' },
    },
}));
/**
 * getRecords order Graphql 类型
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
const OrderType = new graphql_1.GraphQLEnumType({
    name: 'WedaOrderType',
    values: {
        asc: { value: 'asc', description: '升序' },
        desc: { value: 'desc', description: '降序' },
    },
});
/**
 * getRecords 的 入参类型
 */
function getPayloadTypeGetRecords() {
    return {
        orderBy: { type: common_1.SCALAR_TYPES.string, description: '排序字段' },
        orderType: { type: OrderType, description: '排序方式' },
        pageNo: { type: common_1.SCALAR_TYPES.int, description: '页码, 从0开始' },
        pageSize: { type: common_1.SCALAR_TYPES.int, description: '每页大小' },
        where: { type: WhereType, description: '筛选条件' },
    };
}
/**
 * 获取入参类型信息
 * @param schema 数据源入参的 json schema 描述
 * @param isRoot 是否为根结点
 * @param ignoredKeys 忽略的字段
 */
function getPayloadTypeFromSchema(typeName, schema, ignoredKeys) {
    if (schema.type !== 'object') {
        return {
            params: {
                description: (0, common_1.getFieldDescription)(typeName, schema),
                type: getInputTypeFromSchema(typeName, schema),
            },
        };
    }
    const filter = (key) => {
        if (!ignoredKeys)
            return true;
        if (typeof ignoredKeys === 'function')
            return ignoredKeys(key);
        return !ignoredKeys.includes(key);
    };
    return Object.keys(schema.properties)
        .filter(filter)
        .reduce((acc, cur) => {
        const keyProp = schema.properties[cur];
        acc[cur] = {
            description: (0, common_1.getFieldDescription)(cur, keyProp),
            type: getInputTypeFromSchema((0, common_1.getFieldTypeName)(typeName, keyProp, cur), keyProp),
        };
        return acc;
    }, {});
}
exports.getPayloadTypeFromSchema = getPayloadTypeFromSchema;
/**
 * 根据数据源的schema 获取graphql 的类型定义
 * @param typeName 类型名称
 * @param schema 数据源字段 schema
 */
function getInputTypeFromSchema(typeName, schema) {
    // @ts-ignore
    const scalarType = common_1.SCALAR_TYPES[schema.type];
    if (scalarType)
        return scalarType;
    if (schema.type === 'array') {
        return new graphql_1.GraphQLList(getInputTypeFromSchema((0, common_1.getFieldTypeName)(typeName, schema), schema.items));
    }
    if (schema.type === 'object') {
        if (!Object.keys(schema.properties).length)
            return common_1.SCALAR_TYPES.any;
        return new graphql_1.GraphQLInputObjectType({
            name: typeName,
            description: schema.title,
            fields: () => Object.keys(schema.properties)
                .reduce((acc, cur) => {
                const keyProp = schema.properties[cur];
                acc[cur] = {
                    description: (0, common_1.getFieldDescription)(cur, keyProp),
                    type: getInputTypeFromSchema((0, common_1.getFieldTypeName)(typeName, keyProp, cur), keyProp),
                };
                return acc;
            }, {}),
        });
    }
    throw new weda_node_sdk_1.TCBError('GLError.UnsupportedDataType', `GraphQL暂时不支持数据源字段类型${schema.type}`, {
        reason: `unsupported type ${schema.type} in datasource schema`,
    });
}
exports.getInputTypeFromSchema = getInputTypeFromSchema;
