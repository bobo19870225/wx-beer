"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.hasMethodPermission = exports.getMethodCfg = exports.invokeDataSource = void 0;
const fn_context_1 = require("./fn-context");
const builtin_method_1 = require("./builtin-method");
const http_method_1 = require("./http-method");
const cloudfn_method_1 = require("./cloudfn-method");
const scf_method_1 = require("./scf-method");
const remote_api_1 = require("./remote-api");
// import { standardizeParams, logger, TCBError, mergeDeep, isBuiltinMethod, getMethodInParams } from './common';
const common_1 = require("./common");
const config_1 = require("./config");
/**
 * 调用数据源方法
 * @param cfnParams
 * @returns 调用结果
 */
async function invokeDataSource(cfnParams) {
    var _a;
    const dataSource = (0, config_1.getDataSource)(cfnParams.dataSource);
    const defaultParams = (0, config_1.getDefaultParams)(dataSource.name);
    common_1.logger.log(`call ${dataSource.name}'s method ${cfnParams.methodName} with params`, cfnParams.params);
    let fnParams = cfnParams.params || {};
    if (defaultParams) {
        fnParams = (0, common_1.mergeDeep)(defaultParams, fnParams);
    }
    // 临时去掉默认值处理逻辑
    // const inParamsSchema = getMethodInParams(dataSource, cfnParams.methodName, true)
    // if (inParamsSchema) {
    //   fnParams = standardizeParams(fnParams, inParamsSchema)
    //   logger.log('params merged with default values', fnParams)
    // }
    const context = await (0, fn_context_1.getSpecificContext)({ dataSource });
    // 非连接器, 即模型数据源. 因为模型数据源停止更新云函数, 导致云函数中并不能获取模型数据源的描述信息
    if (dataSource.type !== 'cloud-integration') {
        // 在此不再检查内置方法是否启用, 默认均启用, 由后台做 启用 及 权限的校验
        if ((0, common_1.isBuiltinMethod)(cfnParams.methodName)) {
            return (0, builtin_method_1.callBuiltinMethod)(Object.assign(Object.assign({}, cfnParams), { params: fnParams, dataSourceName: dataSource.name }), context);
        }
    }
    const methodCfg = getMethodCfg(dataSource, cfnParams.methodName);
    if (!methodCfg) {
        throw new common_1.TCBError('UserError.DsMethodNotFound', `在数据源 ${dataSource.name} 中找不到方法 ${cfnParams.methodName}`);
    }
    // 是否正在测试当前方法
    const isTestMode = (0, config_1.isMethodInTestMode)(dataSource.name, methodCfg.name);
    // 方法被禁用且未在数据源控制台中进行方法测试
    if (methodCfg.disabled && !isTestMode) {
        throw new common_1.TCBError('UserError.DsMethodNotAllowed.Disabled', `数据源 ${dataSource.name} 的方法 ${cfnParams.methodName} 未启用`);
    }
    // 当前方法处于非测试模式才执行权限校验, 避免无法测试被限制调用权限的自定义方法
    if (!isTestMode) {
        // 不在校验方法权限, 网关层已经进行过校验了
        const hasPermission = true; // await hasMethodPermission(dataSource.id, cfnParams.methodName);
        if (!hasPermission) {
            throw new common_1.TCBError('UserError.DsMethodNotAllowed.NoPermission', `用户没有权限调用数据源 ${dataSource.name} 的方法 ${cfnParams.methodName}`);
        }
    }
    // 向 context 追加 当前调用的方法的相关信息, 可通过 ctx.method.presetParams 访问
    const ctxWithMethodInfo = Object.assign({}, context, {
        method: {
            // @ts-ignore
            presetParams: (_a = methodCfg.calleeBody) === null || _a === void 0 ? void 0 : _a.presetParams,
        },
    });
    if (methodCfg.type === 'http') {
        return (0, http_method_1.callHttpMethod)(Object.assign(Object.assign({}, cfnParams), { params: fnParams, methodCfg, dataSourceName: dataSource.name, isTestMode }), ctxWithMethodInfo);
    }
    if (methodCfg.type === 'cloud-function') {
        return (0, cloudfn_method_1.callCloudMethod)(Object.assign(Object.assign({}, cfnParams), { params: fnParams, methodCfg }), ctxWithMethodInfo);
    }
    // @ts-ignore
    if (methodCfg.type === 'scf') {
        return (0, scf_method_1.callScfMethod)(Object.assign(Object.assign({}, cfnParams), { params: fnParams, methodCfg }), ctxWithMethodInfo);
    }
    // @ts-ignore
    throw new common_1.TCBError('InnerError.DsMethodNotSupport', `尚未支持数据源 ${dataSource.name} 方法 ${cfnParams.methodName} 的类型 ${methodCfg.type}`);
}
exports.invokeDataSource = invokeDataSource;
/**
 * 获取方法配置描述
 */
function getMethodCfg(dsConfig, methodName) {
    if (dsConfig && Array.isArray(dsConfig.methods)) {
        return dsConfig.methods.find(item => (item === null || item === void 0 ? void 0 : item.name) === methodName);
    }
}
exports.getMethodCfg = getMethodCfg;
/**
 * 检查数据源自定义方法方法是否有权限
 * @param dataSourceId 数据源ID (非数据源name)
 * @param methodName 方法名
 * @returns boolean
 */
async function hasMethodPermission(dataSourceId, methodName) {
    if (!dataSourceId)
        throw new common_1.TCBError('UserError.DsNotFound', '未指定数据源标识, 无法对数据源方法进行鉴权');
    const resourceId = `${dataSourceId}#${methodName}`;
    try {
        const result = await (0, remote_api_1.fetchWeda)({
            action: 'DescribeResourcesPermission',
            data: {
                ResourceType: 'dataSource',
                ResourceIdList: [resourceId],
                AppResourceId: (0, config_1.getConfig)('wedaAppId'),
            },
        }).then(res => res.Data);
        if (result === null || result === void 0 ? void 0 : result.length) {
            const item = result.find((n) => n.ResourceId === resourceId);
            return item === null || item === void 0 ? void 0 : item.IsAccess;
        }
        return false;
    }
    catch (error) {
        error.message = `无法校验数据源 ${dataSourceId} 方法 ${methodName} 的权限: ${error.message}`;
        error.reason = `failed to call \`DescribeResourcesPermission\` on datasource ${dataSourceId} with method ${methodName} ${error.reason || ''}`;
        throw error;
    }
}
exports.hasMethodPermission = hasMethodPermission;
