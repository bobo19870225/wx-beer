"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.sendRequest = exports.isSuccessStatusCode = void 0;
const request_1 = __importDefault(require("request"));
const util_1 = __importDefault(require("util"));
const json_transform_1 = require("./json-transform");
const normalize_http_method_1 = require("./normalize-http-method");
const config_1 = require("../config");
const common_1 = require("../common");
/**
 * 合并http header, 使用后边的value覆盖前面的(不会合并value)
 *  这里会处理 header 中的键值对的大小写问题
 */
function mergeHeaders(headers1, headers2) {
    // one of them is empty
    if (!headers1 !== !headers2)
        return headers1 || headers2;
    // both are empty, return empty
    if (!headers1)
        return headers1;
    // 去除 headers1 中与 headers2 中相同的key(忽略大小写), 并根据新的 keys 生产新对象
    const keys2 = Object.keys(headers2).map(k => k.toLowerCase());
    const keys1 = Object.keys(headers1).filter(k => !keys2.includes(k.toLowerCase()));
    const trimmedHeaders = {};
    keys1.reduce((acc, k) => {
        acc[k] = headers1[k];
        return acc;
    }, trimmedHeaders);
    return Object.assign(trimmedHeaders, headers2);
}
/**
 * 解析URL地址
 *  这里不使用node的 url.resolve, 因为会与用户预期不一致 url.resolve('http://example.com/one', '/two');    // 'http://example.com/two'
 * 本算法采取字符串拼接方式来解析URL, 并能移除多余的 / , 也能自动补充缺少的 /
 */
function resolveUrl(baseUrl, url) {
    if (!baseUrl || /^https?:\/\//i.test(url || ''))
        return url;
    if (!url)
        return baseUrl;
    // 处理路径 / 问题
    const baseUrlEndsWithSlash = baseUrl.lastIndexOf('/') === baseUrl.length - 1;
    const urlStartsWithSlash = url.indexOf('/') === 0;
    if (baseUrlEndsWithSlash && urlStartsWithSlash) {
        return baseUrl + url.slice(1);
    }
    if (baseUrlEndsWithSlash || urlStartsWithSlash) {
        return baseUrl + url;
    }
    return `${baseUrl}/${url}`;
}
function isSuccessStatusCode(code) {
    return (code >= 200 && code < 300) || code === 304;
}
exports.isSuccessStatusCode = isSuccessStatusCode;
function hasHeader(headers, headerName) {
    const h = headerName.toLowerCase();
    return Object.keys(headers).some(k => k.toLowerCase() === h);
}
async function sendRequest(ds, rawMethodConfig, context, params) {
    const { finalRequestConfig, methodConfig } = await prepareRequestConfig(ds, rawMethodConfig, params, context);
    common_1.logger.log('finalRequestConfig', finalRequestConfig);
    return new Promise((resolve, reject) => {
        (0, request_1.default)(finalRequestConfig, (error, response, body) => {
            if (error)
                return reject(new common_1.TCBError('FnError.HTTP.NetworkError', `方法 ${methodConfig.name} 底层云函数网络请求失败`, {
                    reason: `http network failed ${error.name}, ${error.message}`,
                    original: error,
                }));
            common_1.logger.log(`http status: ${response.statusCode}, original body:`, body);
            // 处理 body 编码问题
            const contentType = response.caseless.get('content-type');
            let decodedBody = body;
            if (Buffer.isBuffer(body)) {
                let charset = 'utf8';
                if (contentType && /\bcharset\s*=\s*([^\s;]+)/i.test(contentType)) {
                    charset = RegExp.$1.toLowerCase();
                }
                try {
                    const decoder = new util_1.default.TextDecoder(charset, { fatal: true });
                    decodedBody = decoder.decode(body);
                }
                catch (error) {
                    common_1.logger.warn(`unable to decode or not text based content: ${contentType}`);
                }
            }
            if (error) {
                return reject(error);
            }
            if (!isSuccessStatusCode(response.statusCode)) {
                const errorBody = typeof decodedBody !== 'string' ? JSON.stringify(decodedBody) : decodedBody;
                return reject(new common_1.TCBError('FnError.HTTP.StatusError', `HTTP请求失败, 状态码 ${response.statusCode}`, {
                    reason: `http statusCode ${response.statusCode}, response body ${errorBody}`,
                }));
            }
            response.body = decodedBody;
            resolve({ response, body: decodedBody });
        });
    });
}
exports.sendRequest = sendRequest;
/* 准备请求参数 */
async function prepareRequestConfig(ds, rawMethodConfig, params, context) {
    var _a, _b, _c, _d;
    const dsConfig = ds.schema || {};
    const methodConfig = (0, normalize_http_method_1.formatHttpMethodConfig)(rawMethodConfig);
    // 正常不可能出现该错误, 仅为方便后续ts类型推断, 故未对其定义错误代码
    if (methodConfig.type !== 'http') {
        throw new Error(`method ${methodConfig.name} not a valid http datasource method`);
    }
    const tplData = { params, env: context.env, vars: context.vars };
    const httpConfig = methodConfig.calleeBody;
    // transform param placeholders in url
    let requestUrl;
    try {
        requestUrl = (0, json_transform_1.transformJSONWithTemplate)(tplData, resolveUrl(dsConfig.baseUrl, httpConfig.url));
    }
    catch (error) {
        throw new common_1.TCBError('FnError.HTTP.InvalidURL', `方法 ${methodConfig.name} 的请求地址无效: ${error.message}`, {
            reason: `unable to transform ${resolveUrl(dsConfig.baseUrl, httpConfig.url)} with data ${JSON.stringify(tplData)} to a valid url, ${error.message}`,
            original: error,
        });
    }
    if (!/^https?:\/\//i.test(requestUrl)) {
        throw new common_1.TCBError('FnError.HTTP.InvalidURL', `方法 ${methodConfig.name} 的请求地址不是HTTP地址`, {
            reason: `url ${requestUrl} not start with http`,
        });
    }
    const requestMethod = httpConfig.method.toUpperCase();
    const requestConfig = {
        // 避免URL中存在未编码的特殊字符, 导致 node 层直接报错 Request path contains unescaped characters, 拒绝发送请求
        uri: encodeURI(requestUrl),
        method: requestMethod,
        headers: {},
    };
    // TODO: 公共 header 处理, 产品实际并未支持该功能, 公共 header 字段名称可能需要调整
    if (dsConfig.header || ((_a = httpConfig.header) === null || _a === void 0 ? void 0 : _a.values)) {
        const headerFields = mergeHeaders(dsConfig.header, httpConfig.header.values);
        try {
            requestConfig.headers = (0, json_transform_1.transformJSONWithTemplate)(tplData, headerFields) || {};
        }
        catch (error) {
            throw new common_1.TCBError('FnError.HTTP.InvalidHeader', `方法 ${methodConfig.name} 的请求头结构错误: ${error.message}`, {
                reason: `unable to transform header ${JSON.stringify(headerFields)} with data ${JSON.stringify(tplData)}, ${error.message}`,
                original: error,
            });
        }
    }
    if (!hasHeader(requestConfig.headers, 'User-Agent')) {
        requestConfig.headers['User-Agent'] = 'CloudBaseLowCode/2.0';
    }
    // suggest server respond with a json string
    if (!hasHeader(requestConfig.headers, 'Accept')) {
        requestConfig.headers.Accept = 'application/json, text/javascript, */*; q=0.01';
    }
    // 只对受信第三方增加额外的 http header
    if (isTrustedThirdPart(requestUrl, context.vars.TRUSTED_DOMAIN)) {
        const requestId = (0, config_1.getConfig)('requestId');
        let extraHeaders = requestId ? { requestId } : {};
        extraHeaders = getExtraHeaders(Object.assign(extraHeaders, context.extraHeaders));
        requestConfig.headers = mergeHeaders(extraHeaders, requestConfig.headers);
    }
    if (['POST', 'PUT', 'PATCH'].includes(requestMethod) && ((_b = httpConfig.body) === null || _b === void 0 ? void 0 : _b.values)) {
        let body;
        let contentType;
        if ((_c = httpConfig.body) === null || _c === void 0 ? void 0 : _c.values) {
            try {
                body = (0, json_transform_1.transformJSONWithTemplate)(tplData, httpConfig.body.values);
                contentType = httpConfig.body.contentType;
            }
            catch (error) {
                throw new common_1.TCBError('FnError.HTTP.InvalidBody', `方法 ${methodConfig.name} 的请求体格式错误: ${error.message}`, {
                    reason: `unable to transform ${JSON.stringify(httpConfig.body.values)} with data ${tplData}, ${error.message}`,
                    original: error,
                });
            }
        }
        else {
            body = {};
            contentType = 'json';
        }
        switch (contentType) {
            case 'form':
            case 'json':
                try {
                    // body 应为对象
                    const evalBody = typeof body === 'string' ? (0, json_transform_1.evaluateCode)(body, null) : body;
                    if (contentType === 'form') {
                        requestConfig.form = evalBody;
                    }
                    else {
                        requestConfig.body = evalBody;
                        requestConfig.json = true;
                    }
                }
                catch (error) {
                    throw new common_1.TCBError('FnError.HTTP.InvalidBody', `方法 ${methodConfig.name} 的请求体不是正确的JSON`, {
                        reason: `request body ${JSON.stringify(body)} is invalid json string, ${error.message}`,
                        original: error,
                    });
                }
                break;
            case 'xml':
                // can not be merged
                requestConfig.body = String(body);
                requestConfig.headers['Content-Type'] = 'application/xml;charset=UTF-8';
                break;
            case 'raw':
            default:
                requestConfig.body = String(body);
        }
    }
    if ((_d = httpConfig.query) === null || _d === void 0 ? void 0 : _d.values) {
        try {
            const query = (0, json_transform_1.transformJSONWithTemplate)(tplData, httpConfig.query.values);
            requestConfig.qs = query;
        }
        catch (error) {
            throw new common_1.TCBError('FnError.HTTP.InvalidQuery', `方法 ${methodConfig.name} 的请求查询字符串错误: ${error.message}`, {
                reason: `unable to transform ${JSON.stringify(httpConfig.query.values)} with data ${JSON.stringify(tplData)}, ${error.message}`,
                original: error,
            });
        }
    }
    // 强制将返回 body 类型改为 buffer
    requestConfig.encoding = null;
    let finalRequestConfig = requestConfig;
    if (context.httpAuth) {
        const authData = await context.httpAuth.getAuthData(requestConfig);
        finalRequestConfig = mergeAuthData(requestConfig, authData);
    }
    return { finalRequestConfig, methodConfig };
}
/* 合并认证信息 */
function mergeAuthData(requestConfig, authData) {
    const newConfig = Object.assign({}, requestConfig);
    if (authData.uri) {
        newConfig.uri = authData.uri;
    }
    if (authData.body) {
        if (requestConfig.form) {
            newConfig.form = Object.assign(newConfig.form || {}, authData.body);
        }
        else if (!newConfig.body || typeof newConfig.body === 'object') {
            newConfig.body = Object.assign(newConfig.body || {}, authData.body);
            // 再次设置 contentType 为json, 避免 requestConfig.body 为空时未设置 contentType 的问题
            newConfig.json = true;
        }
    }
    if (authData.headers) {
        newConfig.headers = Object.assign(newConfig.headers || {}, authData.headers);
    }
    if (authData.qs) {
        newConfig.qs = Object.assign(newConfig.qs || {}, authData.qs);
    }
    return newConfig;
}
/**
 * 自动处理额外的头信息
 * 会将 {tcloudUin: 'xxxx', envId: 'xxxx'} 转换为 {'X-WEDA-TCLOUD-UIN': 'xxxx', 'X-WEDA-ENV-ID': 'xxxx'}
 */
function getExtraHeaders(extraHeaders) {
    const result = {};
    if (!extraHeaders)
        return result;
    return Object.keys(extraHeaders).reduce((headers, key) => {
        let standardKey = `x-weda-${key.replace(/[A-Z]/g, $0 => `-${$0}`)}`;
        standardKey = standardKey.toUpperCase();
        // eslint-disable-next-line no-param-reassign
        headers[standardKey] = extraHeaders[key];
        return headers;
    }, result);
}
/**
 * 是否为受信的第三方网址
 */
function isTrustedThirdPart(url, trustedDomain) {
    const safeDomains = ['.weda.tencent-cloud.com', '.tcloudbase.com'];
    if (trustedDomain)
        safeDomains.push(trustedDomain);
    try {
        const parsedUrl = new URL(url);
        const { hostname } = parsedUrl;
        return safeDomains.some(d => hostname.endsWith(d));
    }
    catch (error) {
        return false;
    }
}
