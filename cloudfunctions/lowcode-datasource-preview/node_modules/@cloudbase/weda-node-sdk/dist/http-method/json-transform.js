"use strict";
/**
 将 JSON 按照模版转换为另一种结构
 如, 原始json
{
  user: 'Molly',
  age: 12,
  email: 'molly@gmail.com',
  location: {
    city: 'sz',
    street: 'shennan street',
    zipCode: '2323'
  },
  titles: [
    {
      title: '三好学生',
      date: '2017-11-23'
    },
    {
      title: '优秀干部',
      date: '2017-11-23'
    }
  ]
}
模版
{
  userName: '{{user}}',
  userLevel: 2,
  email: '{{email}}',
  location: {
    address: '{{location.city}} {{location.street}}',
    postCode: '{{location.zipCode}}'
  },
  rewards$titles$: {
    name: '{{$item.title}}',
    no: '{{$index + 1}}',
    releaseDate: '{{$item.date}}'
  }
}
转换得到
{
  userName: 'Molly',
  userLevel: 2,
  email: 'molly@gmail.com',
  location: {
    address: 'sz shennan street',
    postCode: '2323'
  },
  rewards: [
    {
      name: '三好学生',
      no: 1,
      releaseDate: '2017-11-23'
    },
    {
      name: '优秀干部',
      no: 1,
      releaseDate: '2017-11-23'
    }
  ]
}

 JSON Template 结构:
 1. 插值使用 {{}} 包裹, 可以直接访问json的值, 亦可以使用表达式
 2. 除数组外, 模版对象中的值均可用插值方式描述
 3. 数组转换时, 因需要同时描述需要循环的字段及值的结构, 描述方式会略有不同:
    循环字段在模版对象的键值中描述, 采用 key$loopKeyPath$ 形式
    值依旧使用插值方式来描述数组成员, 插值中可以使用 $item 访问循环的值, 使用 $index 访问循环索引
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformJSONWithTemplate = exports.getProp = exports.evaluateArr = exports.evaluateVal = exports.isPropPath = exports.evaluateCode = void 0;
function evaluateCode(code, context) {
    if (context && isPropPath(code)) {
        return getProp(context, code);
    }
    try {
        // eslint-disable-next-line no-new-func
        return Function(`with(this){ return (${code})}`).apply(context);
    }
    catch (error) {
        // 使用属性路径访问报错, 则返回 undefined
        if (isPropPath(code))
            return;
        // 补充错误信息, 供外层 TCBError 使用, 这里不再使用 TCBError 再包装
        // @ts-ignore
        error.message = `表达式 \`${code}\` 错误(${error.message})`;
        throw error;
    }
}
exports.evaluateCode = evaluateCode;
/**
 * 判断字符串是否为属性路径
 *  如: abc
 *      abc.sss
 *      abc.ddd["xxxx"].sdf.iwe9
 *      abc.ddd["22"].sdf[90].iwe9
 *      abc.ddd["22"].sdf["90"].iwe9
 * 下边这种虽然是合理的变量路径, 但是模版中使用 getProp 处理解析路径较为复杂, 故判定为非路径
 *      abc.ddd["xxxx"].sdf.iwe9['xxx   sdf']
 *      abc.ddd["xxxx"].sdf.iwe9['xxx  "\'\'\'" sdf']
 */
function isPropPath(propPath) {
    return /^(?:[a-z$_][\da-z_$]*)(?:(?:\.[a-z$_][\da-z_$]*)|(?:\[(?:(?:\d+)|(['"])(|[\da-z_$]+)\1)\]))*$/i.test(propPath);
}
exports.isPropPath = isPropPath;
function evaluateVal(val, context) {
    if (!context)
        return val;
    // no place holder
    if (!/\{\{([^}]+)\}\}/.test(val))
        return val;
    // whole match
    if (/^\{\{([^}]+)\}\}$/.test(val.trim())) {
        return evaluateCode(RegExp.$1, context);
    }
    // partial match
    return val.replace(/\{\{([^}]+)\}\}/g, ($0, $1) => {
        const v = evaluateCode($1, context);
        if (!v) {
            if (typeof v === 'undefined') {
                return '';
            }
            return v;
        }
        ;
        return typeof v === 'string' ? v : JSON.stringify(v);
    });
}
exports.evaluateVal = evaluateVal;
function evaluateArr(template, json, keyPath) {
    const arr = evaluateCode(keyPath, json);
    // 找不到对应成员
    if (!Array.isArray(arr))
        return [];
    return arr.map((item, idx) => {
        const context = Object.assign({}, json, {
            $index: idx,
            $item: item,
        });
        return transformJSONWithTemplate(context, template);
    });
}
exports.evaluateArr = evaluateArr;
/**
 * get value from obj with key path(lodash.get alternative)
 * @param obj object to extract value from
 * @param keyPath value key path, e.g: a.b.c, a[0][3].s.d.e
 * @param defaultValue if get undefined, use defaultValue instead
 */
function getProp(obj, keyPath, defaultValue) {
    const paths = Array.isArray(keyPath)
        ? keyPath
        : String(keyPath)
            .replace(/\[["']?/g, '.')
            .replace(/["']?\]/g, '')
            .split('.');
    let idx = 0;
    const len = paths.length;
    let result = obj;
    // eslint-disable-next-line eqeqeq
    while (result != null && idx < len) {
        result = result[paths[idx]];
        idx += 1;
    }
    return typeof result === 'undefined' ? defaultValue : result;
}
exports.getProp = getProp;
function transformJSONWithTemplate(json, template) {
    if (!json || !template)
        return template;
    // 避免在递归过程中 $root 信息丢失
    // @ts-ignore
    const combinedJson = Object.assign({}, json, { $root: json.$root || json });
    if (typeof template === 'string')
        return evaluateVal(template, combinedJson);
    if (Array.isArray(template))
        return template.map(item => transformJSONWithTemplate(combinedJson, item));
    const keys = Object.keys(template);
    if (!keys.length)
        return {};
    // no key
    if (keys.length === 1 && /^\$(.+)\$$/.test(keys[0])) {
        return evaluateArr(template[keys[0]], combinedJson, RegExp.$1);
    }
    return keys.reduce((acc, cur) => {
        let arrKeyPath = '';
        const key = cur.replace(/\$(.+)\$$/, ($0, $1) => {
            arrKeyPath = $1;
            return '';
        });
        acc[key] = arrKeyPath
            ? evaluateArr(template[cur], combinedJson, arrKeyPath)
            : transformJSONWithTemplate(combinedJson, template[cur]);
        return acc;
    }, {});
}
exports.transformJSONWithTemplate = transformJSONWithTemplate;
