const injectIoc = require('../util/injectIoc');
const { DS_NAME_TAG_MAP, TCB_DS_CONFIG_COL_NAME } = require('./../constant/db');
const { UNVALID_DS_NAME } = require('./../constant/errcode');

const localColNameMap = {}; // 内存缓存
const dsTagList = Object.values(DS_NAME_TAG_MAP); // 数据源标识列表

/**
 * 返回微搭应用ID
 * @returns {string}
 */
function getWedaAppId() {
  const { services: { configService } } = injectIoc();
  return configService.wedaAppId || 'defaultWedaAppId';
}

/**
 * 动态获取数据源名
 * @param {string} dsName 数据源名
 * @returns {string}
 */
function calcDsNameKey(dsName) {
  return `<${getWedaAppId()}>(${dsName})`;
}

/**
 * 检查是否为合法的数据源名称
 * @param {Array<string>} dsNameList
 * @return {boolean}
 */
function checkIsValidDsName(dsNameList) {
  for (const dsName of dsNameList) {
    if (!DS_NAME_TAG_MAP[dsName]) {
      return false;
    }
  }
  return true;
}
/**
 * 检查数据源名称是否换存在内存中
 * @param {Array<string>} dsNameList
 * @returns {boolean}
 */
function checkInMem(dsNameList) {
  for (const dsName of dsNameList) {
    if (!localColNameMap[calcDsNameKey(dsName)]) {
      return false;
    }
  }
  return true;
}
/**
 * 从内存中读取出数据源名称对应的数据表名
 * @param {Array<string>} dsNameList
 * @returns {Array<string>}
 */
function readFromMem(dsNameList) {
  const {
    services: {
      configService: { isDsOnline },
    },
  } = injectIoc();
  return dsNameList.map(dsName => localColNameMap[calcDsNameKey(dsName)] + (isDsOnline ? '' : '-preview'));
}

/**
 * 获取数据源底层的数据表名
 * @param {Array<string>} dsNameList 数据源标识
 * @returns {Promise<Array<string>>}
 */
module.exports = async (dsNameList) => {
  const {
    services: {
      tcbService: { db, envId },
      utilService,
      tcloudRequestService,
      errService,
    },
  } = injectIoc();
  if (!checkIsValidDsName(dsNameList)) {
    errService.throw(UNVALID_DS_NAME, '未配置数据源标识');
  }
  const lcAppId = getWedaAppId(); // 低码应用ID
  // 1. 先从内存中读取，如果不存在，则读取配置表
  if (checkInMem(dsNameList)) {
    return readFromMem(dsNameList);
  }
  const { data } = await db.collection(TCB_DS_CONFIG_COL_NAME)
    .where({ lcAppId })
    .limit(1000)
    .get();
  if (utilService.isValidArray(data)) { // 读取完之后，刷新内存缓存
    for (const item of data) {
      localColNameMap[calcDsNameKey(item.dsName)] = item.colName;
    }
  }
  // 2. 再从最新的内存中读取，如果不存在，则调用接口
  if (checkInMem(dsNameList)) {
    return readFromMem(dsNameList);
  }
  const res = await tcloudRequestService.requestV3({
    service: 'lowcode',
    action: 'DescribeDataSourceList',
    actionParams: {
      PageIndex: 1,
      PageSize: Math.min(dsTagList.length || 10),
      EnvId: envId,
      DataSourceNames: dsTagList,
    },
  });
  const rows = res.Response.Data.Rows;
  const newDataList = [];
  for (const dsName of Reflect.ownKeys(DS_NAME_TAG_MAP)) {
    const item = rows.find(item => item.Name === DS_NAME_TAG_MAP[dsName]);
    if (!item) {
      continue;
    }
    localColNameMap[calcDsNameKey(dsName)] = `lcap-${item.Id}-${item.Name}`; // 刷新本地缓存
    newDataList.push({ dsName, lcAppId, colName: localColNameMap[calcDsNameKey(dsName)] });
  }
  await db.collection(TCB_DS_CONFIG_COL_NAME)
    .where({ lcAppId })
    .remove();
  await db.collection(TCB_DS_CONFIG_COL_NAME).add(newDataList);

  return readFromMem(dsNameList);
};
