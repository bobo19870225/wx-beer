import type { ICloudbase, ICloudbaseConfig } from '@cloudbase/types';
import type { ICloudbaseCache } from '@cloudbase/types/cache';
import type { ICloudbaseRequest } from '@cloudbase/types/request';
import type { ICloudbaseAuthConfig, IUser, IUserInfo, ILoginState } from '@cloudbase/types/auth';
import type { ProviderSubType } from '@cloudbase/oauth/dist/cjs/auth/models';
import type { authModels, AuthOptions, Credentials } from '@cloudbase/oauth';
import { CloudbaseOAuth } from '@cloudbase/oauth';
interface UserInfo {
    uid?: string;
    gender?: string;
    picture?: string;
    email?: string;
    email_verified?: boolean;
    phone_number?: string;
    username?: string;
    name?: string;
    birthdate?: string;
    zoneinfo?: string;
    locale?: string;
    sub?: string;
    created_from?: string;
}
interface IUserOptions {
    cache: ICloudbaseCache;
    oauthInstance: CloudbaseOAuth;
}
interface ILoginStateOptions extends IUserOptions {
    envId: string;
}
export declare class LoginState implements ILoginState {
    user: IUser;
    oauthLoginState: any;
    private oauthInstance;
    private cache;
    constructor(options: ILoginStateOptions);
    checkLocalState(): void;
    checkLocalStateAsync(): Promise<void>;
}
declare class Auth {
    private readonly config;
    private readonly cache;
    private oauthInstance;
    constructor(config: ICloudbaseAuthConfig & {
        cache: ICloudbaseCache;
        request?: ICloudbaseRequest;
        runtime?: string;
    });
    bindPhoneNumber(params: authModels.BindPhoneRequest): Promise<void>;
    unbindProvider(params: authModels.UnbindProviderRequest): Promise<void>;
    bindEmail(params: authModels.BindEmailRequest): Promise<void>;
    verify(params: authModels.VerifyRequest): Promise<authModels.VerifyResponse>;
    getVerification(params: authModels.GetVerificationRequest): Promise<authModels.GetVerificationResponse>;
    get currentUser(): IUser;
    getCurrentUser(): Promise<IUser>;
    signInAnonymously(data?: {
        provider_token?: string;
    }): Promise<LoginState>;
    signInWithOpenId({ useWxCloud }?: {
        useWxCloud?: boolean;
    }): Promise<LoginState>;
    signInWithUnionId(): Promise<LoginState>;
    signInWithPhoneAuth({ phoneCode }: {
        phoneCode?: string;
    }): Promise<LoginState>;
    signInWithSms({ verificationInfo, verificationCode, phoneNum, bindInfo, }: {
        verificationInfo?: {
            verification_id: string;
            is_user: boolean;
        };
        verificationCode?: string;
        phoneNum?: string;
        bindInfo?: any;
    }): Promise<LoginState>;
    setCustomSignFunc(getTickFn: authModels.GetCustomSignTicketFn): void;
    signInWithCustomTicket(params?: {
        version?: string;
    }): Promise<LoginState>;
    signIn(params: authModels.SignInRequest): Promise<LoginState>;
    signUp(params: authModels.SignUpRequest): Promise<LoginState>;
    setPassword(params: authModels.SetPasswordRequest): Promise<void>;
    isUsernameRegistered(username: string): Promise<boolean>;
    signOut(params?: authModels.SignoutRequest): Promise<void | authModels.SignoutReponse>;
    hasLoginState(): LoginState | null;
    getLoginState(): Promise<LoginState>;
    getUserInfo(params?: {
        version?: string;
    }): Promise<IUserInfo>;
    getWedaUserInfo(): Promise<any>;
    updateUserBasicInfo(params: authModels.ModifyUserBasicInfoRequest): Promise<void>;
    getAuthHeader(): {};
    bindWithProvider(params: authModels.BindWithProviderRequest): Promise<void>;
    queryUser(queryObj: authModels.QueryUserProfileRequest): Promise<authModels.QueryUserProfileResponse>;
    getAccessToken(): Promise<{
        accessToken: string;
        env: string;
    }>;
    grantProviderToken(params: authModels.GrantProviderTokenRequest): Promise<authModels.GrantProviderTokenResponse>;
    patchProviderToken(params: authModels.PatchProviderTokenRequest): Promise<authModels.PatchProviderTokenResponse>;
    signInWithProvider(params: authModels.SignInWithProviderRequest): Promise<LoginState>;
    signInWithWechat(params?: any): Promise<LoginState>;
    grantToken(params: authModels.GrantTokenRequest): Promise<LoginState>;
    genProviderRedirectUri(params: authModels.GenProviderRedirectUriRequest): Promise<authModels.GenProviderRedirectUriResponse>;
    resetPassword(params: authModels.ResetPasswordRequest): Promise<void>;
    deviceAuthorize(params: authModels.DeviceAuthorizeRequest): Promise<authModels.DeviceAuthorizeResponse>;
    sudo(params: authModels.SudoRequest): Promise<authModels.SudoResponse>;
    deleteMe(params: authModels.WithSudoRequest): Promise<authModels.UserProfile>;
    getProviders(): Promise<authModels.ProvidersResponse>;
    loginScope(): Promise<string>;
    loginGroups(): Promise<string[]>;
    onLoginStateChanged(callback: Function): Promise<void>;
    refreshTokenForce(params: {
        version?: string;
    }): Promise<Credentials>;
    getCredentials(): Promise<Credentials>;
    setCredentials(credentials: Credentials): Promise<void>;
    getProviderSubType(): Promise<ProviderSubType>;
    createCaptchaData(params: {
        state: string;
        redirect_uri?: string;
    }): Promise<{
        token: string;
        data: string;
    }>;
    verifyCaptchaData(params: {
        token: string;
        key: string;
    }): Promise<{
        captcha_token: string;
        expires_in: number;
    }>;
    getMiniProgramQrCode(params: authModels.GetMiniProgramQrCodeRequest): Promise<authModels.GetMiniProgramQrCodeResponse>;
    getMiniProgramQrCodeStatus(params: authModels.GetMiniProgramQrCodeStatusRequest): Promise<authModels.GetMiniProgramQrCodeStatusResponse>;
    modifyPassword(params: authModels.ModifyUserBasicInfoRequest): Promise<void>;
    modifyPasswordWithoutLogin(params: authModels.ModifyPasswordWithoutLoginRequest): Promise<void>;
    getUserBehaviorLog(params: authModels.GetUserBehaviorLog): Promise<authModels.GetUserBehaviorLogRes>;
    private createLoginState;
}
type TInitAuthOptions = Pick<ICloudbaseAuthConfig, 'region' | 'persistence'> & Partial<AuthOptions>;
export declare function generateAuthInstance(config: TInitAuthOptions, options?: {
    clientId: ICloudbaseConfig['clientId'];
    env: ICloudbaseConfig['env'];
    apiOrigin: string;
    cache?: ICloudbaseCache;
    platform?: ICloudbase['platform'];
    app?: ICloudbase;
    debug?: ICloudbaseAuthConfig['debug'];
}): {
    authInstance: Auth;
    oauthInstance: CloudbaseOAuth;
};
export { UserInfo, Auth };
export declare function registerAuth(app: Pick<ICloudbase, 'registerComponent'>): void;
