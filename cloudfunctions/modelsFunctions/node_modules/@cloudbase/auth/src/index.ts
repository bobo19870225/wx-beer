import type { ICloudbase, ICloudbaseConfig } from '@cloudbase/types'
import type { ICloudbaseCache } from '@cloudbase/types/cache'
import type { ICloudbaseRequest } from '@cloudbase/types/request'
import type { ICloudbaseAuthConfig, IUser, IUserInfo, ILoginState } from '@cloudbase/types/auth'
import type { ICloudbaseComponent } from '@cloudbase/types/component'
import type { GrantProviderTokenResponse, ProviderSubType } from '@cloudbase/oauth/dist/cjs/auth/models'
import type { authModels, AuthOptions, Credentials } from '@cloudbase/oauth'
import { CloudbaseOAuth } from '@cloudbase/oauth'
import { useAuthAdapter } from './adapter'
import {
  printWarn,
  throwError,
  ERRORS,
  COMMUNITY_SITE_URL,
  catchErrorsDecorator,
  CloudbaseEventEmitter,
  CloudbaseCache,
  adapterForWxMp,
  useDefaultAdapter,
} from './utilities'

declare const cloudbase: ICloudbase
declare const wx: any

const COMPONENT_NAME = 'auth'

const EVENTS = {
  // 登录态改变后触发
  LOGIN_STATE_CHANGED: 'loginStateChanged',
}

interface UserInfo {
  uid?: string
  gender?: string
  picture?: string
  email?: string
  email_verified?: boolean
  phone_number?: string
  username?: string
  name?: string
  birthdate?: string
  zoneinfo?: string
  locale?: string
  sub?: string
  created_from?: string
}

const eventBus = new CloudbaseEventEmitter()

interface IUserOptions {
  cache: ICloudbaseCache
  oauthInstance: CloudbaseOAuth
}

class User implements IUser {
  public uid?: string
  public gender?: string
  public picture?: string
  public email?: string
  public emailVerified?: boolean
  public phoneNumber?: string
  public username?: string
  public name?: string
  public providers?: {
    id?: string
    providerUserId?: string
    name?: string
  }[]
  public birthdate?: string
  public zoneinfo?: string
  public locale?: string
  public sub?: string
  public createdFrom?: string

  private cache: ICloudbaseCache
  private oauthInstance: CloudbaseOAuth // CloudbaseOAuth 类型

  constructor(options: IUserOptions) {
    const { cache, oauthInstance } = options
    this.cache = cache
    this.oauthInstance = oauthInstance

    this.setUserInfo()
  }
  /**
   * 获取本地用户信息-同步
   */
  public async checkLocalInfo() {
    this.uid = this.getLocalUserInfo('uid') as string
    this.gender = this.getLocalUserInfo('gender') as string
    this.picture = this.getLocalUserInfo('picture') as string
    this.email = this.getLocalUserInfo('email') as string
    this.emailVerified = this.getLocalUserInfo('email_verified') as boolean
    this.phoneNumber = this.getLocalUserInfo('phone_number') as string
    this.username = this.getLocalUserInfo('username') as string
    this.name = this.getLocalUserInfo('name') as string
    this.birthdate = this.getLocalUserInfo('birthdate') as string
    this.zoneinfo = this.getLocalUserInfo('zoneinfo') as string
    this.locale = this.getLocalUserInfo('locale') as string
    this.sub = this.getLocalUserInfo('sub') as string
    this.createdFrom = this.getLocalUserInfo('created_from') as string
    this.providers = this.getLocalUserInfo('providers') as any
  }
  /**
   * 获取本地用户信息-异步
   */
  public async checkLocalInfoAsync() {
    this.uid = await this.getLocalUserInfoAsync('uid')
    this.gender = await this.getLocalUserInfoAsync('gender')
    this.picture = this.getLocalUserInfo('picture') as string
    this.email = await this.getLocalUserInfoAsync('email')
    this.emailVerified = this.getLocalUserInfo('email_verified') as boolean
    this.phoneNumber = this.getLocalUserInfo('phone_number') as string
    this.username = await this.getLocalUserInfoAsync('username')
    this.name = this.getLocalUserInfo('name') as string
    this.birthdate = this.getLocalUserInfo('birthdate') as string
    this.zoneinfo = this.getLocalUserInfo('zoneinfo') as string
    this.locale = this.getLocalUserInfo('locale') as string
    this.sub = this.getLocalUserInfo('sub') as string
    this.createdFrom = this.getLocalUserInfo('created_from') as string
    this.providers = this.getLocalUserInfo('providers') as any
  }

  /**
   * 更新用户信息
   * @param userInfo
   */
  @catchErrorsDecorator({
    title: '更新用户信息失败',
    messages: [
      '请确认以下各项：',
      '  1 - 调用 User.update() 的语法或参数是否正确',
      '  2 - 用户信息中是否包含非法值',
      `如果问题依然存在，建议到官方问答社区提问或寻找帮助：${COMMUNITY_SITE_URL}`,
    ],
  })
  public async update(userInfo: authModels.UserProfile): Promise<void> {
    // const { name, gender, avatarUrl, province, country, city } = userInfo
    const newUserInfo = await this.oauthInstance.authApi.setUserProfile({ ...userInfo })

    this.setLocalUserInfo(newUserInfo)
  }

  public async updateUserBasicInfo(params: authModels.ModifyUserBasicInfoRequest): Promise<void> {
    await this.oauthInstance.authApi.updateUserBasicInfo({ ...params })
    this.setLocalUserInfo({ username: params.username })
  }

  /**
   * 更新密码
   * @param newPassword
   * @param oldPassword
   */
  @catchErrorsDecorator({
    title: '更新密码失败',
    messages: [
      '请确认以下各项：',
      '  1 - 调用 User.updatePassword() 的语法或参数是否正确',
      '  3 - 新密码中是否包含非法字符',
      `如果问题依然存在，建议到官方问答社区提问或寻找帮助：${COMMUNITY_SITE_URL}`,
    ],
  })
  public updatePassword(newPassword: string, oldPassword: string) {
    return this.oauthInstance.authApi.updatePasswordByOld({
      old_password: oldPassword,
      new_password: newPassword,
    })
  }

  /**
   * 更新用户名
   * @param username
   */
  @catchErrorsDecorator({
    title: '更新用户名失败',
    messages: [
      '请确认以下各项：',
      '  1 - 调用 User.updateUsername() 的语法或参数是否正确',
      '  2 - 当前环境是否开通了用户名密码登录',
      `如果问题依然存在，建议到官方问答社区提问或寻找帮助：${COMMUNITY_SITE_URL}`,
    ],
  })
  public updateUsername(username: string) {
    if (typeof username !== 'string') {
      throwError(ERRORS.INVALID_PARAMS, 'username must be a string')
    }

    return this.update({
      username,
    })
  }

  /**
   * 刷新本地用户信息。当用户在其他客户端更新用户信息之后，可以调用此接口同步更新之后的信息。
   */
  @catchErrorsDecorator({
    title: '刷新本地用户信息失败',
    messages: [
      '请确认以下各项：',
      '  1 - 调用 User.refresh() 的语法或参数是否正确',
      `如果问题依然存在，建议到官方问答社区提问或寻找帮助：${COMMUNITY_SITE_URL}`,
    ],
  })
  public async refresh(params?: { version?: string; query?: any }): Promise<IUserInfo> {
    const newUserInfo = await this.oauthInstance.authApi.getUserInfo(params)
    this.setLocalUserInfo(newUserInfo)
    return newUserInfo
  }

  private getLocalUserInfo(key: string): string | boolean {
    const { userInfoKey } = this.cache.keys
    const userInfo = this.cache.getStore(userInfoKey)
    return userInfo[key]
  }

  private async getLocalUserInfoAsync(key: string): Promise<string> {
    const { userInfoKey } = this.cache.keys
    const userInfo = await this.cache.getStoreAsync(userInfoKey)
    return userInfo[key]
  }

  private setUserInfo() {
    const { userInfoKey } = this.cache.keys
    const userInfo = this.cache.getStore(userInfoKey)
    ;[
      'uid',
      'email',
      'name',
      'gender',
      'picture',
      'email_verified',
      'phone_number',
      'birthdate',
      'zoneinfo',
      'locale',
      'sub',
      'created_from',
      'providers',
      'username',
    ].forEach((infoKey) => {
      this[infoKey] = userInfo[infoKey]
    })
  }

  private setLocalUserInfo(userInfo: any) {
    const { userInfoKey } = this.cache.keys
    this.cache.setStore(userInfoKey, userInfo)
    this.setUserInfo()
  }
}
interface ILoginStateOptions extends IUserOptions {
  envId: string
}
export class LoginState implements ILoginState {
  public user: IUser
  public oauthLoginState: any

  private oauthInstance: CloudbaseOAuth
  private cache: ICloudbaseCache

  constructor(options: ILoginStateOptions) {
    const { envId, cache, oauthInstance } = options
    if (!envId) {
      throwError(ERRORS.INVALID_PARAMS, 'envId is not defined')
    }
    this.cache = cache
    this.oauthInstance = oauthInstance

    this.user = new User({
      cache: this.cache,
      oauthInstance,
    })
  }

  public checkLocalState() {
    this.oauthLoginState = this.oauthInstance?.authApi.hasLoginStateSync()
    this.user.checkLocalInfo()
  }

  public async checkLocalStateAsync() {
    await this.oauthInstance?.authApi.getLoginState()
    await this.user.checkLocalInfoAsync()
  }
}

class Auth {
  private readonly config: ICloudbaseAuthConfig
  private readonly cache: ICloudbaseCache

  private oauthInstance: CloudbaseOAuth

  constructor(config: ICloudbaseAuthConfig & { cache: ICloudbaseCache; request?: ICloudbaseRequest; runtime?: string },) {
    this.config = config
    this.cache = config.cache
    this.oauthInstance = config.oauthInstance
  }

  /**
   * 绑定手机号
   * @param phoneNumber
   * @param phoneCode
   */
  @catchErrorsDecorator({
    title: '绑定手机号失败',
    messages: [
      '请确认以下各项：',
      '  1 - 调用 auth().bindPhoneNumber() 的语法或参数是否正确',
      '  2 - 当前环境是否开通了短信验证码登录',
      `如果问题依然存在，建议到官方问答社区提问或寻找帮助：${COMMUNITY_SITE_URL}`,
    ],
  })
  public async bindPhoneNumber(params: authModels.BindPhoneRequest) {
    return this.oauthInstance.authApi.editContact(params)
  }

  /**
   * 解绑三方绑定
   * @param loginType
   */
  @catchErrorsDecorator({
    title: '解除三方绑定失败',
    messages: [
      '请确认以下各项：',
      '  1 - 调用 auth().unbindProvider() 的语法或参数是否正确',
      '  2 - 当前账户是否已经与此登录方式解绑',
      `如果问题依然存在，建议到官方问答社区提问或寻找帮助：${COMMUNITY_SITE_URL}`,
    ],
  })
  public async unbindProvider(params: authModels.UnbindProviderRequest): Promise<void> {
    return this.oauthInstance.authApi.unbindProvider(params)
  }

  /**
   * 更新邮箱地址
   * @param email
   * @param sudo_token
   * @param verification_token
   */
  @catchErrorsDecorator({
    title: '绑定邮箱地址失败',
    messages: [
      '请确认以下各项：',
      '  1 - 调用 auth().bindEmail() 的语法或参数是否正确',
      '  2 - 当前环境是否开通了邮箱密码登录',
      `如果问题依然存在，建议到官方问答社区提问或寻找帮助：${COMMUNITY_SITE_URL}`,
    ],
  })
  public bindEmail(params: authModels.BindEmailRequest) {
    return this.oauthInstance.authApi.editContact(params)
  }

  /**
   * verify
   * @param {authModels.VerifyRequest} params
   * @returns {Promise<authModels.VerifyResponse>}
   * @memberof User
   */
  @catchErrorsDecorator({
    title: '验证码验证失败',
    messages: [
      '请确认以下各项：',
      '  1 - 调用 auth().verify() 的语法或参数是否正确',
      '  2 - 当前环境是否开通了手机验证码/邮箱登录',
      `如果问题依然存在，建议到官方问答社区提问或寻找帮助：${COMMUNITY_SITE_URL}`,
    ],
  })
  public async verify(params: authModels.VerifyRequest): Promise<authModels.VerifyResponse> {
    return this.oauthInstance.authApi.verify(params)
  }

  /**
   * 获取验证码
   * @param {authModels.GetVerificationRequest} params
   * @returns {Promise<authModels.GetVerificationResponse>}
   * @memberof User
   */
  @catchErrorsDecorator({
    title: '获取验证码失败',
    messages: [
      '请确认以下各项：',
      '  1 - 调用 auth().getVerification() 的语法或参数是否正确',
      '  2 - 当前环境是否开通了手机验证码/邮箱登录',
      `如果问题依然存在，建议到官方问答社区提问或寻找帮助：${COMMUNITY_SITE_URL}`,
    ],
  })
  public async getVerification(params: authModels.GetVerificationRequest): Promise<authModels.GetVerificationResponse> {
    return this.oauthInstance.authApi.getVerification(params)
  }

  /**
   * 获取当前登录的用户信息-同步
   */
  get currentUser() {
    if (this.cache.mode === 'async') {
      // async storage的平台调用此API提示
      printWarn(
        ERRORS.INVALID_OPERATION,
        'current platform\'s storage is asynchronous, please use getCurrentUser insteed',
      )
      return
    }

    const loginState = this.hasLoginState()

    if (loginState) {
      return loginState.user || null
    }
    return null
  }

  /**
   * 获取当前登录的用户信息-异步
   */
  @catchErrorsDecorator({
    title: '获取用户信息失败',
    messages: [
      '请确认以下各项：',
      '  1 - 调用 auth().getCurrentUser() 的语法或参数是否正确',
      `如果问题依然存在，建议到官方问答社区提问或寻找帮助：${COMMUNITY_SITE_URL}`,
    ],
  })
  public async getCurrentUser() {
    const loginState = await this.getLoginState()
    if (loginState) {
      await loginState.user.checkLocalInfoAsync()
      return loginState.user || null
    }
    return null
  }

  /**
   * 匿名登录
   * @returns {Promise<LoginState>}
   * @memberof Auth
   */
  @catchErrorsDecorator({
    title: '匿名登录失败',
    messages: [
      '请确认以下各项：',
      '  1 - 当前环境是否开启了匿名登录',
      '  2 - 调用 auth().signInAnonymously() 的语法或参数是否正确',
      `如果问题依然存在，建议到官方问答社区提问或寻找帮助：${COMMUNITY_SITE_URL}`,
    ],
  })
  public async signInAnonymously(data: {
    provider_token?: string
  } = {},): Promise<LoginState> {
    await this.oauthInstance.authApi.signInAnonymously(data)
    return this.createLoginState()
  }

  /**
   * 小程序openId静默登录
   * @returns {Promise<LoginState>}
   * @memberof Auth
   */
  @catchErrorsDecorator({
    title: '小程序openId静默登录失败',
    messages: [
      '请确认以下各项：',
      '  1 - 当前环境是否开启了小程序openId静默登录',
      '  2 - 调用 auth().signInWithOpenId() 的语法或参数是否正确',
      `如果问题依然存在，建议到官方问答社区提问或寻找帮助：${COMMUNITY_SITE_URL}`,
    ],
  })
  public async signInWithOpenId({ useWxCloud = true } = {}): Promise<LoginState> {
    if (!adapterForWxMp.isMatch()) {
      throw Error('wx api undefined')
    }
    const wxInfo = wx.getAccountInfoSync().miniProgram

    const mainFunc = async (code) => {
      let result: GrantProviderTokenResponse | undefined = undefined
      let credentials: Credentials | undefined = undefined

      try {
        result = await this.oauthInstance.authApi.grantProviderToken(
          {
            provider_id: wxInfo?.appId,
            provider_code: code,
            provider_params: {
              provider_code_type: 'open_id',
              appid: wxInfo?.appId,
            },
          },
          useWxCloud,
        )

        if ((result as any)?.error_code || !result.provider_token) {
          throw result
        }

        credentials = await this.oauthInstance.authApi.signInWithProvider(
          { provider_token: result.provider_token },
          useWxCloud,
        )

        if ((credentials as any)?.error_code) {
          throw credentials
        }
      } catch (error) {
        throw error
      }
      await this.oauthInstance.oauth2client.setCredentials(credentials as Credentials)
    }

    await new Promise((resolve, reject) => {
      wx.login({
        success: async (res: { code: string }) => {
          try {
            await mainFunc(res.code)
            resolve(true)
          } catch (error) {
            reject(error)
          }
        },
        fail: (res: any) => {
          const error = new Error(res?.errMsg)
          ;(error as any).code = res?.errno
          reject(error)
        },
      })
    })

    return this.createLoginState()
  }

  /**
   * 小程序unionId静默登录
   * @returns {Promise<LoginState>}
   * @memberof Auth
   */
  @catchErrorsDecorator({
    title: '小程序unionId静默登录失败',
    messages: [
      '请确认以下各项：',
      '  1 - 当前环境是否开启了小程序unionId静默登录',
      '  2 - 调用 auth().signInWithUnionId() 的语法或参数是否正确',
      `如果问题依然存在，建议到官方问答社区提问或寻找帮助：${COMMUNITY_SITE_URL}`,
    ],
  })
  public async signInWithUnionId(): Promise<LoginState> {
    if (!adapterForWxMp.isMatch()) {
      throw Error('wx api undefined')
    }
    try {
      await new Promise((resolve, reject) => {
        const wxInfo = wx.getAccountInfoSync().miniProgram
        wx.login({
          success: async (res: { code: string }) => {
            const providerId = wxInfo?.appId
            try {
              const result = await this.oauthInstance.authApi.grantProviderToken({
                provider_code: res.code,
                provider_id: providerId,
                provider_params: {
                  provider_code_type: 'union_id',
                  appid: wxInfo?.appId,
                },
              })

              const { provider_token: providerToken } = result

              if (!providerToken) {
                reject(result)
                return
              }

              const signInRes = await this.oauthInstance.authApi.signInWithProvider({
                provider_id: providerId,
                provider_token: providerToken,
              })

              if ((signInRes as any)?.error_code) {
                reject(signInRes)
                return
              }
              resolve(true)
            } catch (error) {
              reject(error)
            }
          },
          fail: (res: any) => {
            const error = new Error(res?.errMsg)
            ;(error as any).code = res?.errno
            reject(error)
          },
        })
      })
    } catch (error) {
      throw error
    }

    return this.createLoginState()
  }

  /**
   * 小程序手机号授权登录
   * @returns {Promise<LoginState>}
   * @memberof Auth
   */
  @catchErrorsDecorator({
    title: '小程序手机号授权登录失败',
    messages: [
      '请确认以下各项：',
      '  1 - 当前环境是否开启了小程序手机号授权登录',
      '  2 - 调用 auth().signInWithPhoneAuth() 的语法或参数是否正确',
      `如果问题依然存在，建议到官方问答社区提问或寻找帮助：${COMMUNITY_SITE_URL}`,
    ],
  })
  public async signInWithPhoneAuth({ phoneCode = '' }): Promise<LoginState> {
    if (!adapterForWxMp.isMatch()) {
      throw Error('wx api undefined')
    }
    const wxInfo = wx.getAccountInfoSync().miniProgram
    const providerInfo = {
      provider_params: { provider_code_type: 'phone' },
      provider_id: wxInfo.appId,
    }

    const { code } = await wx.login()
    ;(providerInfo as any).provider_code = code

    try {
      let providerToken = await this.oauthInstance.authApi.grantProviderToken(providerInfo)
      if (providerToken.error_code) {
        throw providerToken
      }

      providerToken = await this.oauthInstance.authApi.patchProviderToken({
        provider_token: providerToken.provider_token,
        provider_id: wxInfo.appId,
        provider_params: {
          code: phoneCode,
          provider_code_type: 'phone',
        },
      })
      if (providerToken.error_code) {
        throw providerToken
      }

      const signInRes = await this.oauthInstance.authApi.signInWithProvider({
        provider_token: providerToken.provider_token,
      })

      if ((signInRes as any)?.error_code) {
        throw signInRes
      }
    } catch (error) {
      throw error
    }

    return this.createLoginState()
  }

  /**
   * 小程序短信验证码登陆
   * @returns {Promise<LoginState>}
   * @memberof Auth
   */
  @catchErrorsDecorator({
    title: '短信验证码登陆',
    messages: [
      '请确认以下各项：',
      '  1 - 当前环境是否开启了小程序短信验证码登陆',
      '  2 - 调用 auth().signInWithSms() 的语法或参数是否正确',
      `如果问题依然存在，建议到官方问答社区提问或寻找帮助：${COMMUNITY_SITE_URL}`,
    ],
  })
  public async signInWithSms({
    verificationInfo = { verification_id: '', is_user: false },
    verificationCode = '',
    phoneNum = '',
    bindInfo = undefined,
  }): Promise<LoginState> {
    try {
      // 1. 验证验证码
      const verifyRes = await this.oauthInstance.authApi.verify({
        verification_id: verificationInfo.verification_id,
        verification_code: verificationCode,
      })

      if ((verifyRes as any)?.error_code) {
        throw verifyRes
      }

      const { verification_token } = verifyRes

      // 2. 根据是否已经是用户，分别走登录或注册逻辑
      if (verificationInfo.is_user) {
        // 私有化环境或者自定义应用走v1版本的老逻辑
        const signInRes = await this.oauthInstance.authApi.signIn({
          username: `+86 ${phoneNum}`,
          verification_token,
        })

        if ((signInRes as any)?.error_code) {
          throw signInRes
        }

        if (bindInfo) {
          const bindRes = await this.oauthInstance.authApi.bindWithProvider({
            provider_token: (bindInfo as any)?.providerToken,
          })

          if ((bindRes as any)?.error_code) {
            throw bindRes
          }
        }
      } else {
        // 自定义应用走signUp逻辑
        const signUpRes = await this.oauthInstance.authApi.signUp({
          phone_number: `+86 ${phoneNum}`,
          verification_token,
          provider_token: (bindInfo as any)?.providerId,
        })

        if ((signUpRes as any)?.error_code) {
          throw signUpRes
        }
      }

      return this.createLoginState()
    } catch (error) {
      throw error
    }
  }

  /**
   * 设置获取自定义登录 ticket 函数
   * @param {authModels.GetCustomSignTicketFn} getTickFn
   * @memberof Auth
   */
  public setCustomSignFunc(getTickFn: authModels.GetCustomSignTicketFn): void {
    this.oauthInstance.authApi.setCustomSignFunc(getTickFn)
  }

  /**
   *
   * @returns {Promise<LoginState>}
   * @memberof Auth
   */
  @catchErrorsDecorator({
    title: '自定义登录失败',
    messages: [
      '请确认以下各项：',
      '  1 - 当前环境是否开启了自定义登录',
      '  2 - 调用 auth().signInWithCustomTicket() 的语法或参数是否正确',
      '  3 - ticket 是否归属于当前环境',
      '  4 - 创建 ticket 的自定义登录私钥是否过期',
      `如果问题依然存在，建议到官方问答社区提问或寻找帮助：${COMMUNITY_SITE_URL}`,
    ],
  })
  public async signInWithCustomTicket(params?: { version?: string }): Promise<LoginState> {
    await this.oauthInstance.authApi.signInWithCustomTicket(params)
    return this.createLoginState()
  }

  /**
   *
   * @param {authModels.SignInRequest} params
   * @returns {Promise<LoginState>}
   * @memberof Auth
   */
  public async signIn(params: authModels.SignInRequest): Promise<LoginState> {
    await this.oauthInstance.authApi.signIn(params)
    return this.createLoginState(params)
  }

  /**
   *
   * @param {authModels.SignUpRequest} params
   * @returns {Promise<LoginState>}
   * @memberof Auth
   */
  @catchErrorsDecorator({
    title: '注册失败',
    messages: [
      '请确认以下各项：',
      '  1 - 当前环境是否开启了指定登录方式',
      '  2 - 调用 auth().signUp() 的语法或参数是否正确',
      `如果问题依然存在，建议到官方问答社区提问或寻找帮助：${COMMUNITY_SITE_URL}`,
    ],
  })
  public async signUp(params: authModels.SignUpRequest): Promise<LoginState> {
    await this.oauthInstance.authApi.signUp(params)
    return this.createLoginState()
  }

  /**
   * 设置密码
   * @param {authModels.SetPasswordRequest} params
   * @returns {Promise<void>}
   * @memberof Auth
   */
  public async setPassword(params: authModels.SetPasswordRequest): Promise<void> {
    return this.oauthInstance.authApi.setPassword(params)
  }

  /**
   * 检测用户名是否已经占用
   * @param username
   */
  @catchErrorsDecorator({
    title: '获取用户是否被占用失败',
    messages: [
      '请确认以下各项：',
      '  1 - 调用 auth().isUsernameRegistered() 的语法或参数是否正确',
      `如果问题依然存在，建议到官方问答社区提问或寻找帮助：${COMMUNITY_SITE_URL}`,
    ],
  })
  public async isUsernameRegistered(username: string): Promise<boolean> {
    if (typeof username !== 'string') {
      throwError(ERRORS.INVALID_PARAMS, 'username must be a string')
    }

    const { exist } = await this.oauthInstance.authApi.checkIfUserExist({ username })
    return exist
  }

  /**
   * 登出
   */
  @catchErrorsDecorator({
    title: '用户登出失败',
    messages: [
      '请确认以下各项：',
      '  1 - 调用 auth().signOut() 的语法或参数是否正确',
      '  2 - 当前用户是否为匿名登录（匿名登录不支持signOut）',
      `如果问题依然存在，建议到官方问答社区提问或寻找帮助：${COMMUNITY_SITE_URL}`,
    ],
  })
  public async signOut(params?: authModels.SignoutRequest): Promise<void | authModels.SignoutReponse> {
    const { userInfoKey } = this.cache.keys
    const res = await this.oauthInstance.authApi.signOut(params)
    await this.cache.removeStoreAsync(userInfoKey)
    eventBus.fire(EVENTS.LOGIN_STATE_CHANGED)
    return res
  }

  /**
   * 获取本地登录态-同步
   */
  public hasLoginState(): LoginState | null {
    if (this.cache.mode === 'async') {
      // async storage的平台调用此API提示
      printWarn(
        ERRORS.INVALID_OPERATION,
        'current platform\'s storage is asynchronous, please use getLoginState insteed',
      )
      return
    }

    const oauthLoginState = this.oauthInstance?.authApi.hasLoginStateSync()
    if (oauthLoginState) {
      const loginState = new LoginState({
        envId: this.config.env,
        cache: this.cache,
        oauthInstance: this.oauthInstance,
      })
      return loginState
    }
    return null
  }

  /**
   * 获取本地登录态-异步
   * 此API为兼容异步storage的平台
   */
  @catchErrorsDecorator({
    title: '获取本地登录态失败',
    messages: [
      '请确认以下各项：',
      '  1 - 调用 auth().getLoginState() 的语法或参数是否正确',
      `如果问题依然存在，建议到官方问答社区提问或寻找帮助：${COMMUNITY_SITE_URL}`,
    ],
  })
  public async getLoginState() {
    const oauthLoginState = await this.oauthInstance.authApi.getLoginState()
    if (oauthLoginState) {
      const loginState = new LoginState({
        envId: this.config.env,
        cache: this.cache,
        oauthInstance: this.oauthInstance,
      })
      return loginState
    }

    return null
  }

  @catchErrorsDecorator({
    title: '获取用户信息失败',
    messages: [
      '请确认以下各项：',
      '  1 - 是否已登录',
      '  2 - 调用 auth().getUserInfo() 的语法或参数是否正确',
      `如果问题依然存在，建议到官方问答社区提问或寻找帮助：${COMMUNITY_SITE_URL}`,
    ],
  })
  public async getUserInfo(params?: { version?: string }): Promise<IUserInfo> {
    return this.oauthInstance.authApi.getUserInfo(params)
  }

  @catchErrorsDecorator({
    title: '获取微搭插件用户信息失败',
    messages: [
      '请确认以下各项：',
      '  1 - 是否已登录',
      '  2 - 调用 auth().getWedaUserInfo() 的语法或参数是否正确',
      `如果问题依然存在，建议到官方问答社区提问或寻找帮助：${COMMUNITY_SITE_URL}`,
    ],
  })
  public async getWedaUserInfo(): Promise<any> {
    return this.oauthInstance.authApi.getWedaUserInfo()
  }

  public async updateUserBasicInfo(params: authModels.ModifyUserBasicInfoRequest) {
    const loginState = await this.getLoginState()
    if (loginState) {
      await (loginState.user as User).updateUserBasicInfo(params)
    }
    return
  }

  /**
   * getAuthHeader 兼容处理
   * 返回空对象
   */
  public getAuthHeader(): {} {
    console.error('Auth.getAuthHeader API 已废弃')
    return {}
  }

  /**
   * 为已有账户绑第三方账户
   * @param {authModels.BindWithProviderRequest} params
   * @returns {Promise<void>}
   * @memberof Auth
   */
  @catchErrorsDecorator({
    title: '绑定第三方登录方式失败',
    messages: [
      '请确认以下各项：',
      '  1 - 调用 auth().bindWithProvider() 的语法或参数是否正确',
      '  2 - 此账户是否已经绑定此第三方',
      `如果问题依然存在，建议到官方问答社区提问或寻找帮助：${COMMUNITY_SITE_URL}`,
    ],
  })
  public async bindWithProvider(params: authModels.BindWithProviderRequest): Promise<void> {
    return this.oauthInstance.authApi.bindWithProvider(params)
  }

  /**
   * 查询用户
   * @param {authModels.QueryUserProfileRequest} appended_params
   * @returns {Promise<authModels.UserProfile>}
   * @memberof Auth
   */
  public async queryUser(queryObj: authModels.QueryUserProfileRequest): Promise<authModels.QueryUserProfileResponse> {
    return this.oauthInstance.authApi.queryUserProfile(queryObj)
  }

  public async getAccessToken() {
    const oauthAccessTokenRes = await this.oauthInstance.oauth2client.getAccessToken()
    return {
      accessToken: oauthAccessTokenRes,
      env: this.config.env,
    }
  }

  public async grantProviderToken(params: authModels.GrantProviderTokenRequest,): Promise<authModels.GrantProviderTokenResponse> {
    return this.oauthInstance.authApi.grantProviderToken(params)
  }

  public async patchProviderToken(params: authModels.PatchProviderTokenRequest,): Promise<authModels.PatchProviderTokenResponse> {
    return this.oauthInstance.authApi.patchProviderToken(params)
  }

  public async signInWithProvider(params: authModels.SignInWithProviderRequest): Promise<LoginState> {
    await this.oauthInstance.authApi.signInWithProvider(params)
    return this.createLoginState(params)
  }

  public async signInWithWechat(params: any = {}) {
    await this.oauthInstance.authApi.signInWithWechat(params)
    return this.createLoginState(params)
  }

  public async grantToken(params: authModels.GrantTokenRequest): Promise<LoginState> {
    await this.oauthInstance.authApi.grantToken(params)
    return this.createLoginState()
  }

  public async genProviderRedirectUri(params: authModels.GenProviderRedirectUriRequest,): Promise<authModels.GenProviderRedirectUriResponse> {
    return this.oauthInstance.authApi.genProviderRedirectUri(params)
  }

  public async resetPassword(params: authModels.ResetPasswordRequest): Promise<void> {
    return this.oauthInstance.authApi.resetPassword(params)
  }

  public async deviceAuthorize(params: authModels.DeviceAuthorizeRequest): Promise<authModels.DeviceAuthorizeResponse> {
    return this.oauthInstance.authApi.deviceAuthorize(params)
  }

  public async sudo(params: authModels.SudoRequest): Promise<authModels.SudoResponse> {
    return this.oauthInstance.authApi.sudo(params)
  }

  public async deleteMe(params: authModels.WithSudoRequest): Promise<authModels.UserProfile> {
    return this.oauthInstance.authApi.deleteMe(params)
  }

  public async getProviders(): Promise<authModels.ProvidersResponse> {
    return this.oauthInstance.authApi.getProviders()
  }

  public async loginScope(): Promise<string> {
    return this.oauthInstance.authApi.loginScope()
  }

  public async loginGroups(): Promise<string[]> {
    return this.oauthInstance.authApi.loginGroups()
  }

  public async onLoginStateChanged(callback: Function) {
    eventBus.on(EVENTS.LOGIN_STATE_CHANGED, async () => {
      const loginState = await this.getLoginState()
      callback.call(this, loginState)
    })
    // 立刻执行一次回调
    const loginState = await this.getLoginState()
    callback.call(this, loginState)
  }

  /**
   * 强制刷新token
   * @param params
   * @returns
   */
  public async refreshTokenForce(params: { version?: string }): Promise<Credentials> {
    return this.oauthInstance.authApi.refreshTokenForce(params)
  }

  /**
   * 获取身份信息
   * @returns
   */
  public async getCredentials(): Promise<Credentials> {
    return this.oauthInstance.authApi.getCredentials()
  }
  /**
   * 写入身份信息
   */
  public async setCredentials(credentials: Credentials) {
    await this.oauthInstance.oauth2client.setCredentials(credentials)
  }

  @catchErrorsDecorator({
    title: '获取身份源类型',
    messages: [
      '请确认以下各项：',
      '  1 - 调用 auth().getProviderSubType() 的语法或参数是否正确',
      `如果问题依然存在，建议到官方问答社区提问或寻找帮助：${COMMUNITY_SITE_URL}`,
    ],
  })
  public async getProviderSubType(): Promise<ProviderSubType> {
    return this.oauthInstance.authApi.getProviderSubType()
  }

  public async createCaptchaData(params: { state: string; redirect_uri?: string }) {
    return this.oauthInstance.authApi.createCaptchaData(params)
  }

  public async verifyCaptchaData(params: { token: string; key: string }) {
    return this.oauthInstance.authApi.verifyCaptchaData(params)
  }

  public async getMiniProgramQrCode(params: authModels.GetMiniProgramQrCodeRequest,): Promise<authModels.GetMiniProgramQrCodeResponse> {
    return this.oauthInstance.authApi.getMiniProgramCode(params)
  }

  public async getMiniProgramQrCodeStatus(params: authModels.GetMiniProgramQrCodeStatusRequest,): Promise<authModels.GetMiniProgramQrCodeStatusResponse> {
    return this.oauthInstance.authApi.getMiniProgramQrCodeStatus(params)
  }

  public async modifyPassword(params: authModels.ModifyUserBasicInfoRequest): Promise<void> {
    return this.oauthInstance.authApi.modifyPassword(params)
  }

  public async modifyPasswordWithoutLogin(params: authModels.ModifyPasswordWithoutLoginRequest): Promise<void> {
    return this.oauthInstance.authApi.modifyPasswordWithoutLogin(params)
  }

  public async getUserBehaviorLog(params: authModels.GetUserBehaviorLog): Promise<authModels.GetUserBehaviorLogRes> {
    return this.oauthInstance.authApi.getUserBehaviorLog(params)
  }

  private async createLoginState(params?: { version?: string; query?: any }): Promise<LoginState> {
    const loginState = new LoginState({
      envId: this.config.env,
      cache: this.cache,
      oauthInstance: this.oauthInstance,
    })

    await loginState.checkLocalStateAsync()
    await loginState.user.refresh(params)
    eventBus.fire(EVENTS.LOGIN_STATE_CHANGED)
    return loginState
  }
}

type TInitAuthOptions = Pick<ICloudbaseAuthConfig, 'region' | 'persistence'> & Partial<AuthOptions>

export function generateAuthInstance(
  config: TInitAuthOptions,
  options?: {
    clientId: ICloudbaseConfig['clientId']
    env: ICloudbaseConfig['env']
    apiOrigin: string
    cache?: ICloudbaseCache
    platform?: ICloudbase['platform']
    app?: ICloudbase
    debug?: ICloudbaseAuthConfig['debug']
  },
) {
  const { region = 'ap-shanghai' } = config
  const platform = options?.platform || useDefaultAdapter()
  const { runtime } = platform

  const { env, clientId, debug, cache, app: cloudbase } = options || {}
  let { apiOrigin } = options || {}
  if (!apiOrigin) {
    apiOrigin = `https://${env}.${region}.tcb-api.tencentcloudapi.com`
  }
  const oauthInstance = new CloudbaseOAuth(useAuthAdapter({
    env,
    clientId,
    apiOrigin,
    // @todo 以下最好走adaptor处理，目前oauth模块没按adaptor接口设计
    storage: config?.storage,
    baseRequest: config?.baseRequest,
    request: config?.request,
    anonymousSignInFunc: config?.anonymousSignInFunc,
    captchaOptions: config?.captchaOptions,
    wxCloud: config?.wxCloud,
  }),)

  const authInstance = new Auth({
    env,
    region,
    persistence: config.persistence,
    debug,
    cache:
      cache
      || new CloudbaseCache({
        persistence: config.persistence,
        keys: { userInfoKey: `user_info_${env}` },
        platformInfo: platform,
      }),
    runtime: runtime || 'web',
    _fromApp: cloudbase,
    oauthInstance,
  })

  return { authInstance, oauthInstance }
}

const component: ICloudbaseComponent = {
  name: COMPONENT_NAME,
  namespace: 'auth',
  entity(config: TInitAuthOptions = {
    region: '',
    persistence: 'local',
  },) {
    if (this.authInstance) {
      printWarn(ERRORS.INVALID_OPERATION, 'every cloudbase instance should has only one auth object')
      return this.authInstance
    }
    const { adapter } = this.platform
    // 如不明确指定persistence则优先取各平台adapter首选，其次localStorage
    const newPersistence = config.persistence || adapter.primaryStorage
    if (newPersistence && newPersistence !== this.config.persistence) {
      this.updateConfig({ persistence: newPersistence })
    }

    const { authInstance, oauthInstance } = generateAuthInstance(
      {
        wxCloud: this.config.wxCloud,
        storage: this.config.storage,
        ...config,
        persistence: this.config.persistence,
      },
      {
        env: this.config.env,
        clientId: this.config.clientId,
        apiOrigin: this.request.getBaseEndPoint(),
        platform: this.platform,
        cache: this.cache,
        app: this,
        debug: this.config.debug,
      },
    )

    this.oauthInstance = oauthInstance

    this.authInstance = authInstance

    return this.authInstance
  },
}

try {
  // 尝试自动注册至全局变量cloudbase
  // 此行为只在浏览器环境下有效
  cloudbase.registerComponent(component)
} catch (e) {}

export { UserInfo, Auth }
/**
 * @api 手动注册至cloudbase app
 */
export function registerAuth(app: Pick<ICloudbase, 'registerComponent'>) {
  try {
    app.registerComponent(component)
  } catch (e) {
    console.warn(e)
  }
}
