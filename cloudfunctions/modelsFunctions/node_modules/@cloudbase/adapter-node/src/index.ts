import {
  IFetchOptions,
  IRequestConfig,
  IRequestMethod,
  IRequestOptions,
  ResponseObject,
  SDKAdapterInterface,
  SDKRequestInterface,
  StorageInterface,
  StorageType,
  WebSocketContructor as WebSocketConstructor,
  formatUrl,
} from "@cloudbase/adapter-interface";
import WS from "ws";
import { utils } from "@cloudbase/utilities";
import { Readable } from "node:stream";

const { isFormData, toQueryString } = utils as {
  isFormData: (obj: unknown) => boolean;
  toQueryString: (data: Record<string, any>) => string;
};

function dynamicImport<T, U>(url: string, cb: (x: T) => U): () => Promise<U> {
  let ret: U;
  return async () => {
    if (ret) {
      return ret;
    }
    const importRes = (await import(url)) as T;
    ret = cb(importRes);
    return ret;
  };
}

const importFetch = dynamicImport<
  // @ts-expect-error import type only
  typeof import("node-fetch"),
  // @ts-expect-error import type only
  typeof import("node-fetch").default
>("node-fetch", (x) => x.default);

export class NodeRequest implements SDKRequestInterface {
  // 默认不限超时
  private readonly timeout: number;
  // 超时提示文案
  private readonly timeoutMsg: string;
  // 超时受限请求类型，默认所有请求均受限
  private readonly restrictedMethods: Array<IRequestMethod>;
  constructor(config: IRequestConfig) {
    const { timeout, timeoutMsg, restrictedMethods } = config;
    this.timeout = timeout || 0;
    this.timeoutMsg = timeoutMsg || "请求超时";
    this.restrictedMethods = restrictedMethods || [
      "get",
      "post",
      "upload",
      "download",
    ];
  }
  public get(options: IRequestOptions): Promise<ResponseObject> {
    return this.request(
      {
        ...options,
        method: "get",
      },
      this.restrictedMethods.includes("get"),
    );
  }
  public post(options: IRequestOptions): Promise<ResponseObject> {
    return this.request(
      {
        ...options,
        method: "post",
      },
      this.restrictedMethods.includes("post"),
    );
  }
  public put(options: IRequestOptions): Promise<ResponseObject> {
    return this.request({
      ...options,
      method: "put",
    });
  }
  public upload(options: IRequestOptions): Promise<ResponseObject> {
    const { data: _data, file, name, method, headers = {} } = options;
    if (file === undefined || name == undefined) {
      throw new Error("file and name is required");
    }
    const data = obj2StrRecord(_data ?? {}),
      loweredMethod = method?.toLowerCase(),
      reqMethod = ["post", "put"].find((m) => m === loweredMethod) ?? "put",
      // 上传方式为post时，需转换为FormData
      formData = new FormData();
    if (reqMethod === "post") {
      Object.keys(data).forEach((key) => {
        formData.append(key, data[key]);
      });
      formData.append("key", name);
      formData.append("file", file);
      return this.request(
        {
          ...options,
          data: formData,
          method: reqMethod,
        },
        this.restrictedMethods.includes("upload"),
      );
    }
    return this.request(
      {
        ...options,
        method: "put",
        headers,
        body: file,
      },
      this.restrictedMethods.includes("upload"),
    );
  }
  public async download(options: IRequestOptions): Promise<unknown> {
    const { data } = await this.get({
      ...options,
      headers: {}, // 下载资源请求不经过service，header清空
      responseType: "blob",
    });
    const url = window.URL.createObjectURL(new Blob([data]));
    const fileName = decodeURIComponent(
      new URL(options?.url ?? "").pathname.split("/").pop() || "",
    );
    const link = document.createElement("a");

    link.href = url;
    link.setAttribute("download", fileName);
    link.style.display = "none";

    document.body.appendChild(link);
    link.click();
    // 回收内存
    window.URL.revokeObjectURL(url);
    document.body.removeChild(link);
    return new Promise((resolve) => {
      resolve({
        statusCode: 200,
        tempFilePath: options.url,
      });
    });
  }
  async fetch(options: IFetchOptions): Promise<ResponseObject> {
    const { url, enableAbort = false, stream = false } = options,
      abortController = new AbortController();

    let timer = undefined;
    if (enableAbort && this.timeout) {
      timer = setTimeout(() => {
        console.warn(this.timeoutMsg);
        abortController.abort(new Error(this.timeoutMsg));
      }, this.timeout);
    }

    const res = await (
      await importFetch()
    )(url, {
      ...options,
      headers: options.headers
        ? headersInit2Indexable(options.headers)
        : undefined,
      body: options.body as any as NodeJS.ReadableStream,
      signal: abortController.signal,
    })
      .then((x) => {
        clearTimeout(timer);
        return x;
      })
      .catch((x) => {
        clearTimeout(timer);
        return Promise.reject(x);
      });

    const ret = {
      data: stream
        ? res.body
          ? Readable.toWeb(res.body as Readable)
          : res.body
        : res.json(),
      statusCode: res.status,
      header: res.headers,
    };
    return ret;
  }

  protected async request(
    options: IRequestOptions,
    enableAbort = false,
  ): Promise<ResponseObject> {
    const {
        url,
        headers: _headers = {},
        data,
        responseType,
        withCredentials,
        body,
        method: _method,
      } = options,
      headers = obj2StrRecord(_headers),
      method = String(_method).toLowerCase() || "get",
      realUrl = formatUrl("https", url ?? "", method === "get" ? data : {}),
      controller = new AbortController(),
      { signal } = controller;

    let timer;

    if (enableAbort && this.timeout) {
      timer = setTimeout(() => {
        console.warn(this.timeoutMsg);
        controller.abort(new Error(this.timeoutMsg));
      }, this.timeout);
    }

    let payload;
    if (isFormData(data)) {
      // FormData，不处理
      payload = data;
    } else if (
      headers["content-type"] === "application/x-www-form-urlencoded"
    ) {
      payload = toQueryString(data ?? {});
    } else if (body) {
      payload = body;
    } else {
      // 其它情况
      payload = data ? JSON.stringify(data) : undefined;
    }

    const requestOptions = {
      method,
      headers,
      body: payload,
      credentials: withCredentials ? "include" : "same-origin",
      signal,
    };

    try {
      const response = await (await importFetch())(realUrl, requestOptions),
        result: ResponseObject = {
          header: {},
          statusCode: response.status,
        };

      try {
        // 上传post请求返回数据格式为xml，此处容错
        result.data =
          responseType === "blob"
            ? await response.blob()
            : await response.json();
      } catch (_) {
        result.data =
          responseType === "blob"
            ? await response.blob()
            : await response.text();
      }

      const { headers } = response;
      headers.forEach((val, key) => (result.header[key.toLowerCase()] = val));

      return result;
    } finally {
      clearTimeout(timer);
    }
  }
}

/**
 * 判断当前环境是否为 Node.js 环境
 */
function isMatch(): boolean {
  return (
    typeof process !== "undefined" &&
    process.versions != null &&
    process.versions.node != null
  );
}

const storage: StorageInterface = (() => {
  const db = new Map();
  return {
    mode: "sync",
    setItem(key, value) {
      db.set(key, value);
    },
    getItem(key) {
      return db.get(key);
    },
    removeItem(key) {
      db.delete(key);
    },
    clear() {
      db.clear();
    },
  };
})();

function genAdapter() {
  // 小程序无sessionStorage
  const adapter: SDKAdapterInterface = {
    root: {},
    reqClass: NodeRequest,
    wsClass: WS as WebSocketConstructor,
    sessionStorage: storage,
    primaryStorage: StorageType.session,
  };
  return adapter;
}

const adapter = {
  genAdapter,
  isMatch,
  runtime: "node",
};

export default adapter;

function obj2StrRecord(obj: object): Record<string, string> {
  return Object.entries(obj).reduce<Record<string, string>>(
    (acc, cur: [string, unknown]) => {
      const [key, value] = cur;
      acc[key] = String(value);
      return acc;
    },
    {},
  );
}

function headersInit2Indexable(h: HeadersInit) {
  if (isHeaders(h)) {
    const ret: Record<string, string> = {};
    h.forEach((val, key) => {
      ret[key] = val;
    });
    return ret;
  }
  return h;

  function isHeaders(h: HeadersInit): h is Headers {
    return h instanceof Headers;
  }
}

module.exports = adapter;
module.exports.default = adapter;
