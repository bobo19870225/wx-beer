import { ErrorType } from './consts';
import { ApiUrls, ApiUrlsV2 } from '../auth/consts';
import { uuidv4 } from '../utils/uuid';
import { getPathName } from '../utils/index';
import { SinglePromise } from '../utils/function/single-promise';
import { weBtoa } from '../utils/base64';
import { isMatch } from '../utils/cloudbase-adapter-wx_mp';
const RequestIdHeaderName = 'x-request-id';
const DeviceIdHeaderName = 'x-device-id';
const DeviceIdSectionName = 'device_id';
export const defaultRequest = async function (url, options) {
    let result = null;
    let responseError = null;
    try {
        const copyOptions = Object.assign({}, options);
        if (!copyOptions.method) {
            copyOptions.method = 'GET';
        }
        if (copyOptions.body && typeof copyOptions.body !== 'string') {
            copyOptions.body = JSON.stringify(copyOptions.body);
        }
        const responseResult = await fetch(url, copyOptions);
        const jsonResponse = await responseResult.json();
        if (jsonResponse?.error) {
            responseError = jsonResponse;
            responseError.error_uri = new URL(url).pathname;
        }
        else {
            result = jsonResponse;
        }
    }
    catch (error) {
        responseError = {
            error: ErrorType.UNREACHABLE,
            error_description: error.message,
            error_uri: new URL(url).pathname,
        };
    }
    if (responseError) {
        throw responseError;
    }
    else {
        return result;
    }
};
export const toResponseError = (error, options) => {
    let responseError;
    const formatOptions = options || {};
    if (error instanceof Error) {
        responseError = {
            error: formatOptions.error || ErrorType.LOCAL,
            error_description: formatOptions.error_description || error.message,
            error_uri: formatOptions.error_uri,
            details: formatOptions.details || error.stack,
        };
    }
    else {
        const formatError = error || {};
        responseError = {
            error: formatOptions.error || formatError.error || ErrorType.LOCAL,
            error_description: formatOptions.error_description || formatError.error_description,
            error_uri: formatOptions.error_uri || formatError.error_uri,
            details: formatOptions.details || formatError.details,
        };
    }
    return responseError;
};
export function generateRequestId() {
    return uuidv4();
}
class DefaultStorage {
    constructor(opts) {
        this._env = opts?.env || '';
    }
    async getItem(key) {
        return window.localStorage.getItem(`${key}${this._env}`);
    }
    async removeItem(key) {
        window.localStorage.removeItem(`${key}${this._env}`);
    }
    async setItem(key, value) {
        window.localStorage.setItem(`${key}${this._env}`, value);
    }
    getItemSync(key) {
        return window.localStorage.getItem(`${key}${this._env}`);
    }
    removeItemSync(key) {
        window.localStorage.removeItem(`${key}${this._env}`);
    }
    setItemSync(key, value) {
        window.localStorage.setItem(`${key}${this._env}`, value);
    }
}
export const defaultStorage = new DefaultStorage();
function isCredentialsExpired(credentials) {
    let isExpired = true;
    if (credentials?.expires_at && credentials?.access_token) {
        isExpired = credentials.expires_at < new Date();
    }
    return isExpired;
}
class LocalCredentials {
    constructor(options) {
        this.credentials = null;
        this.singlePromise = new SinglePromise();
        this.tokenSectionName = options.tokenSectionName;
        this.storage = options.storage;
    }
    getStorageCredentialsSync() {
        let credentials = null;
        const tokenStr = this.storage.getItemSync(this.tokenSectionName);
        if (tokenStr !== undefined && tokenStr !== null) {
            try {
                credentials = JSON.parse(tokenStr);
                if (credentials?.expires_at) {
                    credentials.expires_at = new Date(credentials.expires_at);
                }
            }
            catch (error) {
                this.storage.removeItem(this.tokenSectionName);
                credentials = null;
            }
        }
        return credentials;
    }
    async setCredentials(credentials) {
        if (credentials?.expires_in) {
            if (!credentials?.expires_at) {
                credentials.expires_at = new Date(Date.now() + (credentials.expires_in - 30) * 1000);
            }
            if (this.storage) {
                const tokenStr = JSON.stringify(credentials);
                await this.storage.setItem(this.tokenSectionName, tokenStr);
            }
            this.credentials = credentials;
        }
        else {
            if (this.storage) {
                await this.storage.removeItem(this.tokenSectionName);
            }
            this.credentials = null;
        }
    }
    async getCredentials() {
        return this.singlePromise.run('getCredentials', async () => {
            if (isCredentialsExpired(this.credentials)) {
                this.credentials = await this.getStorageCredentials();
            }
            return this.credentials;
        });
    }
    async getStorageCredentials() {
        return this.singlePromise.run('_getStorageCredentials', async () => {
            let credentials = null;
            const tokenStr = await this.storage.getItem(this.tokenSectionName);
            if (tokenStr !== undefined && tokenStr !== null) {
                try {
                    credentials = JSON.parse(tokenStr);
                    if (credentials?.expires_at) {
                        credentials.expires_at = new Date(credentials.expires_at);
                    }
                }
                catch (error) {
                    await this.storage.removeItem(this.tokenSectionName);
                    credentials = null;
                }
            }
            return credentials;
        });
    }
}
class OAuth2Client {
    constructor(options) {
        this.singlePromise = new SinglePromise();
        if (!options.clientSecret) {
            options.clientSecret = '';
        }
        if (!options.clientId && options.env) {
            options.clientId = options.env;
        }
        this.apiOrigin = options.apiOrigin;
        this.clientId = options.clientId;
        this.retry = this.formatRetry(options.retry, OAuth2Client.defaultRetry);
        if (options.baseRequest) {
            this.baseRequest = options.baseRequest;
        }
        else {
            this.baseRequest = defaultRequest;
        }
        this.tokenInURL = options.tokenInURL;
        this.headers = options.headers;
        this.storage = options.storage || defaultStorage;
        this.localCredentials = new LocalCredentials({
            tokenSectionName: `credentials_${options.clientId}`,
            storage: this.storage,
        });
        this.clientSecret = options.clientSecret;
        if (options.clientId) {
            this.basicAuth = `Basic ${weBtoa(`${options.clientId}:${this.clientSecret}`)}`;
        }
        this.wxCloud = options.wxCloud;
        try {
            if (isMatch() && this.wxCloud === undefined && options.env) {
                wx.cloud.init({ env: options.env });
                this.wxCloud = wx.cloud;
            }
        }
        catch (error) {
        }
        this.refreshTokenFunc = options.refreshTokenFunc || this.defaultRefreshTokenFunc;
        this.anonymousSignInFunc = options.anonymousSignInFunc;
    }
    setCredentials(credentials) {
        return this.localCredentials.setCredentials(credentials);
    }
    async getAccessToken() {
        const credentials = await this.getCredentials();
        if (credentials?.access_token) {
            return Promise.resolve(credentials.access_token);
        }
        const respErr = { error: ErrorType.UNAUTHENTICATED };
        return Promise.reject(respErr);
    }
    async request(url, options) {
        if (!options) {
            options = {};
        }
        const retry = this.formatRetry(options.retry, this.retry);
        options.headers = options.headers || {};
        if (this.headers) {
            options.headers = {
                ...this.headers,
                ...options.headers,
            };
        }
        if (!options.headers[RequestIdHeaderName]) {
            options.headers[RequestIdHeaderName] = generateRequestId();
        }
        if (!options.headers[DeviceIdHeaderName]) {
            const deviceId = await this.getDeviceId();
            options.headers[DeviceIdHeaderName] = deviceId;
        }
        if (options?.withBasicAuth && this.basicAuth) {
            options.headers.Authorization = this.basicAuth;
        }
        if (options?.withCredentials) {
            const credentials = await this.getCredentials();
            if (credentials) {
                if (this.tokenInURL) {
                    if (url.indexOf('?') < 0) {
                        url += '?';
                    }
                    url += `access_token=${credentials.access_token}`;
                }
                else {
                    options.headers.Authorization = `${credentials.token_type} ${credentials.access_token}`;
                }
            }
        }
        else {
            if (this.clientId && url.indexOf('client_id') < 0) {
                url += url.indexOf('?') < 0 ? '?' : '&';
                url += `client_id=${this.clientId}`;
            }
        }
        if (url.startsWith('/')) {
            url = this.apiOrigin + url;
        }
        let response = null;
        const maxRequestTimes = retry + 1;
        for (let requestTime = 0; requestTime < maxRequestTimes; requestTime++) {
            try {
                if (options.useWxCloud) {
                    response = await this.wxCloudCallFunction(url, options);
                }
                else {
                    response = await this.baseRequest(url, options);
                }
                break;
            }
            catch (responseError) {
                if (options.withCredentials && responseError && responseError.error === ErrorType.UNAUTHENTICATED) {
                    await this.setCredentials(null);
                    return Promise.reject(responseError);
                }
                if (requestTime === retry || !responseError || responseError.error !== 'unreachable') {
                    return Promise.reject(responseError);
                }
            }
            await this.sleep(OAuth2Client.retryInterval);
        }
        return response;
    }
    async wxCloudCallFunction(url, options) {
        let result = null;
        let responseError = null;
        try {
            const userAgent = await wx.getRendererUserAgent();
            const { result: responseResult } = await this.wxCloud.callFunction({
                name: 'httpOverCallFunction',
                data: {
                    url,
                    method: options.method,
                    headers: {
                        origin: 'https://servicewechat.com',
                        'User-Agent': userAgent,
                        ...options.headers,
                    },
                    body: options.body,
                },
            });
            if (responseResult?.body?.error_code) {
                responseError = responseResult?.body;
                responseError.error_uri = getPathName(url);
            }
            else {
                result = responseResult?.body;
            }
        }
        catch (error) {
            responseError = {
                error: ErrorType.UNREACHABLE,
                error_description: error.message,
                error_uri: getPathName(url),
            };
        }
        if (responseError) {
            throw responseError;
        }
        else {
            return result;
        }
    }
    async getCredentials() {
        let credentials = await this.localCredentials.getCredentials();
        if (!credentials) {
            return this.unAuthenticatedError('credentials not found');
        }
        if (isCredentialsExpired(credentials)) {
            if (credentials && credentials.scope === 'anonymous') {
                if (this.anonymousSignInFunc) {
                    const c = await this.anonymousSignInFunc(credentials);
                    credentials = c || (await this.localCredentials.getCredentials());
                }
                else {
                    credentials = await this.anonymousSignIn(credentials);
                }
            }
            else {
                credentials = await this.refreshToken(credentials);
            }
        }
        return credentials;
    }
    getCredentialsSync() {
        const credentials = this.localCredentials.getStorageCredentialsSync();
        return credentials;
    }
    getCredentialsAsync() {
        return this.getCredentials();
    }
    async getScope() {
        const credentials = await this.localCredentials.getCredentials();
        if (!credentials) {
            return this.unAuthenticatedError('credentials not found');
        }
        return credentials.scope;
    }
    async getGroups() {
        const credentials = await this.localCredentials.getCredentials();
        if (!credentials) {
            return this.unAuthenticatedError('credentials not found');
        }
        return credentials.groups;
    }
    async refreshToken(credentials) {
        return this.singlePromise.run('_refreshToken', async () => {
            if (!credentials || !credentials.refresh_token) {
                return this.unAuthenticatedError('no refresh token found in credentials');
            }
            try {
                const newCredentials = await this.refreshTokenFunc(credentials.refresh_token, credentials);
                await this.localCredentials.setCredentials(newCredentials);
                return newCredentials;
            }
            catch (error) {
                if (error.error === ErrorType.INVALID_GRANT) {
                    await this.localCredentials.setCredentials(null);
                    return this.unAuthenticatedError(error.error_description);
                }
                return Promise.reject(error);
            }
        });
    }
    checkRetry(retry) {
        let responseError = null;
        if (typeof retry !== 'number' || retry < OAuth2Client.minRetry || retry > OAuth2Client.maxRetry) {
            responseError = {
                error: ErrorType.UNREACHABLE,
                error_description: 'wrong options param: retry',
            };
        }
        if (responseError) {
            throw responseError;
        }
        return retry;
    }
    formatRetry(retry, defaultVale) {
        if (typeof retry === 'undefined') {
            return defaultVale;
        }
        return this.checkRetry(retry);
    }
    async sleep(ms) {
        return new Promise((resolve) => {
            setTimeout(() => {
                resolve();
            }, ms);
        });
    }
    async anonymousSignIn(credentials) {
        return this.singlePromise.run('_anonymous', async () => {
            if (!credentials || credentials.scope !== 'anonymous') {
                return this.unAuthenticatedError('no anonymous in credentials');
            }
            try {
                const newCredentials = await this.request(ApiUrls.AUTH_SIGN_IN_ANONYMOUSLY_URL, {
                    method: 'POST',
                    withBasicAuth: true,
                    body: {},
                });
                await this.localCredentials.setCredentials(newCredentials);
                return newCredentials;
            }
            catch (error) {
                if (error.error === ErrorType.INVALID_GRANT) {
                    await this.localCredentials.setCredentials(null);
                    return this.unAuthenticatedError(error.error_description);
                }
                return Promise.reject(error);
            }
        });
    }
    async defaultRefreshTokenFunc(refreshToken, credentials) {
        if (refreshToken === undefined || refreshToken === '') {
            return this.unAuthenticatedError('refresh token not found');
        }
        let url = ApiUrls.AUTH_TOKEN_URL;
        if (credentials?.version === 'v2') {
            url = ApiUrlsV2.AUTH_TOKEN_URL;
        }
        const newCredentials = await this.request(url, {
            method: 'POST',
            body: {
                client_id: this.clientId,
                client_secret: this.clientSecret,
                grant_type: 'refresh_token',
                refresh_token: refreshToken,
            },
        });
        return { ...newCredentials, version: credentials?.version || 'v1' };
    }
    async getDeviceId() {
        if (this.deviceID) {
            return this.deviceID;
        }
        let deviceId = await this.storage.getItem(DeviceIdSectionName);
        if (!(typeof deviceId === 'string' && deviceId.length >= 16 && deviceId.length <= 48)) {
            deviceId = uuidv4();
            await this.storage.setItem(DeviceIdSectionName, deviceId);
        }
        this.deviceID = deviceId;
        return deviceId;
    }
    unAuthenticatedError(err) {
        const respErr = {
            error: ErrorType.UNAUTHENTICATED,
            error_description: err,
        };
        return Promise.reject(respErr);
    }
}
OAuth2Client.defaultRetry = 2;
OAuth2Client.minRetry = 0;
OAuth2Client.maxRetry = 5;
OAuth2Client.retryInterval = 1000;
export { OAuth2Client };
