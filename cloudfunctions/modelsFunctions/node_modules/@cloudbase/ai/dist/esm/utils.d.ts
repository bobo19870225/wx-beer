import { type ParsedEvent } from 'eventsource-parser';
import type { AsyncIterableReadableStream } from './type';
export declare const ReadableStream: {
    new (underlyingSource: UnderlyingByteSource, strategy?: {
        highWaterMark?: number;
    }): ReadableStream<Uint8Array>;
    new <R = any>(underlyingSource: UnderlyingDefaultSource<R>, strategy?: QueuingStrategy<R>): ReadableStream<R>;
    new <R_1 = any>(underlyingSource?: UnderlyingSource<R_1>, strategy?: QueuingStrategy<R_1>): ReadableStream<R_1>;
    prototype: ReadableStream;
};
export declare const TransformStream: {
    new <I = any, O = any>(transformer?: Transformer<I, O>, writableStrategy?: QueuingStrategy<I>, readableStrategy?: QueuingStrategy<O>): TransformStream<I, O>;
    prototype: TransformStream;
};
export declare const createEventSourceParserTransformStream: () => TransformStream<string, ParsedEvent>;
export declare const toPolyfillReadable: import("@mattiasbuelens/web-streams-adapter").ReadableStreamWrapper;
export declare class TextDecoderStream {
    private handle;
    private transform;
    constructor(encoding?: string, options?: TextDecoderOptions);
    get encoding(): string;
    get fatal(): boolean;
    get ignoreBOM(): boolean;
    get readable(): ReadableStream<any>;
    get writable(): WritableStream<any>;
    get [Symbol.toStringTag](): string;
}
export declare function createAsyncIterable<T>(stream: ReadableStream<T>): AsyncIterableReadableStream<T>;
