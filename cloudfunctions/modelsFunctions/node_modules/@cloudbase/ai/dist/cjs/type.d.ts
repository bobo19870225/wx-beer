import { type ParsedEvent } from 'eventsource-parser';
export declare abstract class ChatModel {
    abstract generateText(data: BaseChatModelInput): Promise<{
        text: string;
        rawResponse: any;
    }>;
    abstract streamText(data: BaseChatModelInput): Promise<StreamTextResult>;
}
export type ChatModelConstructor = typeof ChatModel;
export declare abstract class StreamTextResult {
    abstract eventSourceStream: AsyncIterableReadableStream<ParsedEvent>;
    abstract dataStream: AsyncIterableReadableStream<any>;
    abstract textStream: AsyncIterableReadableStream<string>;
}
export type AsyncIterableReadableStream<T> = ReadableStream<T> & {
    [Symbol.asyncIterator]: () => {
        next(): Promise<IteratorResult<T>>;
    };
};
export interface IModelReqInput {
    url: string;
    headers?: Record<string, string>;
    data?: Object;
    stream?: boolean;
}
export type ModelReq = <T extends IModelReqInput>(props: T) => T['stream'] extends true ? Promise<ReadableStream<Uint8Array>> : Promise<Object>;
export interface IBotReqInput {
    url: string;
    method: string;
    headers?: Record<string, string>;
    data?: Object;
    stream?: boolean;
}
export type BotReq = <T extends IBotReqInput>(props: T) => T['stream'] extends true ? Promise<ReadableStream<Uint8Array>> : Promise<Object>;
type ChatModelMessage = {
    role: 'user' | 'system' | 'assistant';
    content: string;
};
export interface BaseChatModelInput {
    model: string;
    messages: Array<ChatModelMessage>;
    temperature?: number;
    top_p?: number;
}
export {};
