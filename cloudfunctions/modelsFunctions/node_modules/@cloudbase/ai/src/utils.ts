import { TransformStream as _TransformStream, ReadableStream as _ReadableStream } from 'web-streams-polyfill'
import { createReadableStreamWrapper } from '@mattiasbuelens/web-streams-adapter'
import { createParser, type EventSourceParser, type ParsedEvent } from 'eventsource-parser'
import type { AsyncIterableReadableStream } from './type'
import { TextDecoder } from 'text-encoding-shim'

export const ReadableStream = _ReadableStream as {
  prototype: ReadableStream

  new (
    underlyingSource: UnderlyingByteSource,
    strategy?: {
      highWaterMark?: number
    },
  ): ReadableStream<Uint8Array>
  new <R = any>(underlyingSource: UnderlyingDefaultSource<R>, strategy?: QueuingStrategy<R>): ReadableStream<R>
  new <R = any>(underlyingSource?: UnderlyingSource<R>, strategy?: QueuingStrategy<R>): ReadableStream<R>
}

export const TransformStream = _TransformStream as {
  prototype: TransformStream

  new <I = any, O = any>(
    transformer?: Transformer<I, O>,
    writableStrategy?: QueuingStrategy<I>,
    readableStrategy?: QueuingStrategy<O>,
  ): TransformStream<I, O>
}

export const createEventSourceParserTransformStream = () => {
  let parser!: EventSourceParser

  return new TransformStream<string, ParsedEvent>({
    start(controller) {
      parser = createParser((event) => {
        if (event.type === 'event') {
          controller.enqueue(event)
        }
      })
    },
    transform(chunk) {
      parser.feed(chunk)
    },
  })
}

export const toPolyfillReadable = createReadableStreamWrapper(ReadableStream)

export class TextDecoderStream {
  private handle: TextDecoder

  private transform = new TransformStream({
    transform: (chunk, controller) => {
      const value = this.handle.decode(new Uint8Array(chunk), { stream: true })

      if (value) {
        controller.enqueue(value)
      }
    },
    flush: (controller) => {
      const value = this.handle.decode()
      if (value) {
        controller.enqueue(value)
      }

      controller.terminate()
    },
  })

  constructor(encoding = 'utf-8', options: TextDecoderOptions = {}) {
    this.handle = new TextDecoder(encoding, options)
  }

  get encoding() {
    return this.handle.encoding
  }

  get fatal() {
    return this.handle.fatal
  }

  get ignoreBOM() {
    return this.handle.ignoreBOM
  }

  get readable() {
    return this.transform.readable
  }

  get writable() {
    return this.transform.writable
  }

  get [Symbol.toStringTag]() {
    return 'TextDecoderStream'
  }
}

export function createAsyncIterable<T>(stream: ReadableStream<T>) {
  const _stream = stream as AsyncIterableReadableStream<T>
  _stream[Symbol.asyncIterator] = () => {
    const reader = stream.getReader()
    return {
      async next(): Promise<IteratorResult<T>> {
        const { done, value } = await reader.read()
        return done ? { done: true, value: undefined } : { done: false, value }
      },
    }
  }
  return _stream
}
