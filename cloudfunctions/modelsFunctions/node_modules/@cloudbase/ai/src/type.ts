import { type ParsedEvent } from 'eventsource-parser'

export abstract class ChatModel {
  public abstract generateText(data: BaseChatModelInput): Promise<{ text: string; rawResponse: any }>

  public abstract streamText(data: BaseChatModelInput): Promise<StreamTextResult>
}

export type ChatModelConstructor = typeof ChatModel

export abstract class StreamTextResult {
  public abstract eventSourceStream: AsyncIterableReadableStream<ParsedEvent>
  public abstract dataStream: AsyncIterableReadableStream<any>
  public abstract textStream: AsyncIterableReadableStream<string>
}

export type AsyncIterableReadableStream<T> = ReadableStream<T> & {
  [Symbol.asyncIterator]: () => { next(): Promise<IteratorResult<T>> }
}

export interface IModelReqInput {
  url: string
  headers?: Record<string, string>
  data?: Object
  stream?: boolean
}

export type ModelReq = <T extends IModelReqInput>(
  props: T,
) => T['stream'] extends true ? Promise<ReadableStream<Uint8Array>> : Promise<Object>

export interface IBotReqInput {
  url: string
  method: string
  headers?: Record<string, string>
  data?: Object
  stream?: boolean
}

export type BotReq = <T extends IBotReqInput>(
  props: T,
) => T['stream'] extends true ? Promise<ReadableStream<Uint8Array>> : Promise<Object>

type ChatModelMessage = {
  role: 'user' | 'system' | 'assistant'
  content: string
}

export interface BaseChatModelInput {
  model: string
  messages: Array<ChatModelMessage>
  temperature?: number
  top_p?: number
}
