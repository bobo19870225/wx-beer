import { type ParsedEvent } from 'eventsource-parser'
import {
  createAsyncIterable,
  TransformStream,
  TextDecoderStream,
  createEventSourceParserTransformStream,
  toPolyfillReadable,
} from '../../utils'
import type { HunYuanInputData, HunYaunGenerateTextOutput, HunYaunStreamTextOutput } from './type'
import type { ChatModel, StreamTextResult, ModelReq, BaseChatModelInput } from '../../type'

export class HunYuanModel implements ChatModel {
  public subUrl = 'hunyuan'
  constructor(private req: ModelReq, public baseUrl: string, subUrl?: string) {
    if (subUrl != null) {
      this.subUrl = subUrl
    }
  }

  private get url() {
    return `${this.baseUrl}/${this.subUrl}`
  }

  async generateText(data: BaseChatModelInput) {
    const processedData = this.processInput(data)
    const res = (await this.req({
      url: this.url,
      headers: {
        'X-Tc-Action': 'ChatCompletions',
      },
      data: {
        ...processedData,
        Stream: false,
      },
      stream: false,
    })) as HunYaunGenerateTextOutput
    return {
      text: (res?.choices?.[0]?.message?.content as string) ?? '',
      rawResponse: res,
    }
  }

  async streamText(data: BaseChatModelInput) {
    const processedData = this.processInput(data)
    const stream = await this.req({
      url: this.url,
      headers: {
        'X-Tc-Action': 'ChatCompletions',
      },
      data: {
        ...processedData,
        Stream: true,
      },
      stream: true,
    })
    return new HunyuanModelStreamResult(stream)
  }

  private processInput({ messages, model, temperature, top_p, ...rest }: BaseChatModelInput): HunYuanInputData {
    return {
      Messages: messages.map(({ content, role }) => ({ Content: content, Role: role })),
      Model: model as any,
      Temperature: temperature,
      TopP: top_p,
      ...rest,
    }
  }
}

class HunyuanModelStreamResult implements StreamTextResult {
  private _eventSourceStream: ReadableStream<ParsedEvent>

  constructor(_stream: ReadableStream<Uint8Array>) {
    const stream = toPolyfillReadable(_stream) as typeof _stream
    this._eventSourceStream = stream
      .pipeThrough(new TextDecoderStream())
      .pipeThrough(createEventSourceParserTransformStream())
  }

  private get teeedStream() {
    const [s1, s2] = this._eventSourceStream.tee()
    this._eventSourceStream = s2
    return s1
  }

  get eventSourceStream() {
    return createAsyncIterable(this.teeedStream)
  }

  get dataStream() {
    return createAsyncIterable(this.eventSourceStream.pipeThrough(new TransformStream<ParsedEvent, HunYaunStreamTextOutput>({
      transform(chunk, controller) {
        try {
          const data = JSON.parse(chunk.data) as HunYaunStreamTextOutput
          controller.enqueue(data)
        } catch (e) {
          if (chunk.data !== '[DONE]') {
            console.warn('Error when transforming event source data to json', e)
          }
        }
      },
    }),),)
  }

  get textStream() {
    return createAsyncIterable(this.dataStream.pipeThrough(new TransformStream<HunYaunStreamTextOutput, string>({
      transform(chunk, controller) {
        controller.enqueue(chunk?.choices?.[0]?.delta?.content ?? '')
      },
    }),),)
  }
}
